/// <reference types="node" />
/**
 * @module Model/Transaction
 */
import { AssetOptions, UpdateMonitoredAssetParameters } from './asset';
import { Key, KeyParts, Price } from './content';
import { Block } from './explorer';
import AssetExchangeRate = Block.AssetExchangeRate;
import { Authority, Options } from './account';
import { MonitoredAssetOptions } from './asset';
import { Proposal } from './proposal';
import * as prototype from './operationPrototype';
import { OperationType } from './operationPrototype';
/**
 * OperationType to be broadcasted to blockchain
 * internal representation
 */
export declare abstract class Operation {
    name: OperationName;
    operation: prototype.OperationType;
    protected constructor(name: OperationName, type?: prototype.OperationType);
}
/**
 * Memo message object representation
 */
export interface Memo {
    from: string;
    to: string;
    nonce: string;
    message: Buffer;
}
/**
 * Class contains available transaction operation names constants
 */
export declare enum OperationName {
    transfer = "transfer",
    content_cancellation = "content_cancellation",
    requestToBuy = "request_to_buy",
    content_submit = "content_submit",
    account_update = "account_update",
    asset_create = "asset_create",
    issue_asset = "asset_issue",
    update_user_issued_asset = "update_user_issued_asset",
    asset_fund_pools_operation = "asset_fund_pools_operation",
    asset_reserve_operation = "asset_reserve_operation",
    asset_claim_fees_operation = "asset_claim_fees_operation",
    leave_rating_and_comment = "leave_rating_and_comment",
    account_create = "account_create",
    asset_publish_feed = "asset_publish_feed",
    miner_create = "miner_create",
    miner_update = "miner_update",
    miner_update_global_parameters = "miner_update_global_parameters",
    proposal_create = "proposal_create",
    proposal_update = "proposal_update",
    operation_wrapper = "op_wrapper",
    vesting_balance_withdraw = "vesting_balance_withdraw",
    subscribe = "subscribe",
    subscribe_by_author = "subscribe_by_author",
    automatic_renewal_of_subscription = "automatic_renewal_of_subscription",
    custom_operation = "custom",
    update_monitored_asset_operation = "update_monitored_asset_operation",
}
/**
 * Asset represent amount of specific
 * asset.
 */
export declare class Asset {
    amount: number;
    asset_id: string;
}
/**
 * Operations collection which can be constructed and send to blockchain network
 */
export declare namespace Operations {
    class TransferOperation extends Operation {
        static getPrototype(): prototype.TransferType;
        constructor(from: string, to: string, amount: Asset, memo: Memo);
    }
    class ContentCancelOperation extends Operation {
        static getPrototype(): prototype.ContentCancellationType;
        constructor(author: string, URI: string);
    }
    class BuyContentOperation extends Operation {
        static getPrototype(): prototype.BuyContentType;
        constructor(URI: string, consumer: string, price: Asset, region_code_from: number, pubKey: Key);
    }
    class SubmitContentOperation extends Operation {
        static getPrototype(): prototype.SubmitContentType;
        constructor(size: number, author: string, co_authors: any[], URI: string, quorum: number, price: RegionalPrice[], hash: string, seeders: string[], key_parts: KeyParts[], expiration: string, publishing_fee: Asset, synopsis: string);
    }
    class AccountUpdateOperation extends Operation {
        static getPrototype(): prototype.UpdateAccountType;
        constructor(account: string, owner: Authority, active: Authority, new_options: Options, extensions: {});
    }
    class AssetCreateOperation extends Operation {
        static getPrototype(): prototype.AssetCreateType;
        constructor(issuer: string, symbol: string, precision: number, description: string, options: AssetOptions, monitoredOptions?: MonitoredAssetOptions);
    }
    class IssueAssetOperation extends Operation {
        static getPrototype(): prototype.IssueAssetType;
        constructor(issuer: string, assetToIssue: Asset, issueToAccount: string, memo?: Memo);
    }
    class UpdateAssetIssuedOperation extends Operation {
        static getPrototype(): prototype.UpdateIssuedAssetType;
        constructor(issuer: string, asset_to_update: string, new_description: string, max_supply: number, core_exchange_rate: AssetExchangeRate, is_exchangeable: boolean, new_issuer?: string);
    }
    class AssetFundPools extends Operation {
        static getPrototype(): prototype.AssetFundPoolsType;
        constructor(fromAccountId: string, uiaAsset: Asset, dctAsset: Asset);
    }
    class AssetReserve extends Operation {
        static getPrototype(): prototype.AssetReserveType;
        constructor(payer: string, assetToReserve: Asset);
    }
    class AssetClaimFeesOperation extends Operation {
        static getPrototype(): prototype.AssetClaimFeesType;
        constructor(issuer: string, uiaAsset: Asset, dctAsset: Asset);
    }
    class LeaveRatingAndComment extends Operation {
        static getPrototype(): prototype.LeaveRatingAndCommentType;
        constructor(URI: string, consumer: string, comment: string, rating: number);
    }
    class AssetPublishFeed extends Operation {
        static getPrototype(): object;
        constructor(publisher: string, assetId: string, feed: PriceFeed);
    }
    class MinerCreate extends Operation {
        static getPrototype(): prototype.MinerCreateType;
        constructor(miner_account: string, url: string, block_signing_key: string);
    }
    class MinerUpdate extends Operation {
        static getPrototype(): prototype.MinerUpdateType;
        constructor(miner: string, minerAccount: string, newURL?: string, newSigningKey?: string);
    }
    class MinerUpdateGlobalParameters extends Operation {
        static getPrototype(): prototype.MinerUpdateGlobalParametersType;
        constructor(proposalParameters: Proposal);
    }
    class ProposalCreate extends Operation {
        static getPrototype(): prototype.ProposalCreateType;
        constructor(feePayingAccount: string, proposedOperations: OperationType[], expirationTime: string, reviewPeriodSeconds?: number);
    }
    class ProposalUpdate extends Operation {
        static getPrototype(): prototype.ProposalUpdateType;
        constructor(feePayingAccount: string, proposal: string, activeApprovalsToAdd: Array<string>, activeApprovalsToRemove: Array<string>, ownerApprovalsToAdd: Array<string>, ownerApprovalsToRemove: Array<string>, keyApprovalsToAdd: Array<string>, keyApprovalsToRemove: Array<string>);
    }
    class OperationWrapper extends Operation {
        static getPrototype(): prototype.OperationWrapperType;
        constructor(operation: Operation);
    }
    interface CreateAccountParameters {
        fee?: Asset;
        name?: string;
        owner?: Authority;
        active?: Authority;
        options?: Options;
        registrar?: string;
        extensions?: any;
    }
    class RegisterAccount extends Operation {
        static getPrototype(): prototype.CreateAccountType;
        constructor(params: CreateAccountParameters);
    }
    class VestingBalanceWithdraw extends Operation {
        static getPrototype(): prototype.VestingBalanceWithdrawType;
        constructor(vestingBalanceId: string, ownerId: string, ammount: Asset);
    }
    class Subscribe extends Operation {
        static getPrototype(): prototype.SubscribeType;
        constructor(fromId: string, toId: string, price: Asset);
    }
    class SubscribeByAuthor extends Operation {
        static getPrototype(): prototype.SubscribeByAuthorType;
        constructor(fromId: string, toId: string);
    }
    class SetAutomaticRenewalOfSubscription extends Operation {
        static getPrototype(): prototype.AutomaticRenewalOfSubscriptionType;
        constructor(accountId: string, subscriptionId: string, automaticRenewal: boolean);
    }
    class CustomOperation extends Operation {
        constructor(payer: any, required_auths: any, id: number, data: any);
    }
    class UpdateMonitoredAssetOperation extends Operation {
        static getPrototype(): prototype.UpdateMonitoredAssetType;
        constructor(params: UpdateMonitoredAssetParameters);
    }
}
export interface RegionalPrice {
    region: number;
    price: Asset;
}
export interface PriceFeed {
    core_exchange_rate: AssetExchangeRate;
}
export interface ContentObject {
    author: string;
    co_authors: [string, number];
    expiration: number;
    created: number;
    price: Price;
    synopsis: string;
    size: number;
    quorum: number;
    URI: string;
    key_parts: [string, string];
    last_proof: [string, number];
    seeder_price: [string, any];
    is_blocked: boolean;
    _hash: string;
    AVG_rating: number;
    num_of_ratings: number;
    times_bought: number;
    publishing_fee_escrow: Asset;
    cd: any;
}
