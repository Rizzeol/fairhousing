"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
/**
 * @module ChainApi
 */
var helpers_1 = require("../helpers");
var chain_1 = require("./model/chain");
var ChainApi = /** @class */ (function () {
    function ChainApi(apiConnector, chainStore) {
        this._apiConnector = apiConnector;
        this._chainStore = chainStore;
    }
    Object.defineProperty(ChainApi.prototype, "chainId", {
        get: function () {
            return helpers_1.dcorejs_lib.ChainConfig.networks.decent.chain_id;
        },
        enumerable: true,
        configurable: true
    });
    /**
     * Generates random sequence of bytes
     */
    ChainApi.generateNonce = function () {
        return helpers_1.dcorejs_lib.TransactionHelper.unique_nonce_uint64();
    };
    ChainApi.setupChain = function (chainId, chainConfig) {
        chainConfig.networks.decent = {
            chain_id: chainId
        };
    };
    /**
     * Fetches data from blockchain with given chain methods.
     *
     * Returns Promise.all with resolve result as array of results
     * in order of adding into ChainMethod
     *
     * @param {ChainMethods} methods
     * @return {Promise<any[]>}
     */
    ChainApi.prototype.fetch = function () {
        var _this = this;
        var methods = [];
        for (var _i = 0; _i < arguments.length; _i++) {
            methods[_i] = arguments[_i];
        }
        return new Promise(function (resolve, reject) {
            _this.connect()
                .then(function (res) {
                var commands = methods.map(function (method) { return helpers_1.dcorejs_lib.FetchChain(method.name, method.parameters); });
                Promise.all(commands)
                    .then(function (result) { return resolve(result); })
                    .catch(function (err) {
                    var e = new Error(chain_1.ChainError.command_execution_failed);
                    e.stack = err;
                    reject(e);
                });
            })
                .catch(function (err) {
                reject(err);
            });
        });
    };
    ChainApi.prototype.subscribe = function (callback) {
        var _this = this;
        this.connect()
            .then(function (res) {
            _this._chainStore.subscribe(callback);
        })
            .catch(function (err) { return console.log(err); });
    };
    ChainApi.prototype.subscribePendingTransactions = function (callback) {
        var _this = this;
        this.connect()
            .then(function (res) {
            _this._chainStore.subscribePendingTransaction(callback);
        })
            .catch(function (err) { return console.log(err); });
    };
    ChainApi.prototype.subscribeBlockApplied = function (callback) {
        var _this = this;
        this.connect()
            .then(function (res) {
            _this._chainStore.subscribeBlockApplied(callback);
        })
            .catch(function (err) { return console.log(err); });
    };
    ChainApi.prototype.connect = function () {
        var _this = this;
        return new Promise((function (resolve, reject) {
            _this._apiConnector
                .connect()
                .then(function () {
                _this._chainStore.init()
                    .then(function () { return resolve(); })
                    .catch(function (err) { return reject(err); });
            })
                .catch(function (err) { return reject(err); });
        }));
    };
    ChainApi.asset = 'DCT';
    ChainApi.asset_id = '1.3.0';
    ChainApi.DCTPower = Math.pow(10, 8);
    return ChainApi;
}());
exports.ChainApi = ChainApi;
//# sourceMappingURL=chain.js.map