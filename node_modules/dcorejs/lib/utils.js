"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
/**
 * @module Utils
 */
var helpers_1 = require("./helpers");
var crypt_1 = require("./crypt");
var chain_1 = require("./api/chain");
var dictionary_1 = require("./resources/dictionary");
var BigInteger = require("big-integer");
var js_sha512_1 = require("js-sha512");
/**
 * PKI private key
 */
var KeyPrivate = /** @class */ (function () {
    function KeyPrivate(privateKey) {
        this._privateKey = privateKey;
    }
    /**
     * Create KeyPrivate from brain key.
     *
     * @param {string} brainKey     Brain key to generate private key from.
     * @param {number} sequence     Sequence number, for generating derived private key
     * @returns {KeyPrivate}        KeyPrivate instance.
     */
    KeyPrivate.fromBrainKey = function (brainKey, sequence) {
        if (sequence === void 0) { sequence = 0; }
        var pKey = helpers_1.dcorejs_lib.key.get_brainPrivateKey(brainKey, sequence);
        return new KeyPrivate(pKey);
    };
    /**
     * Create KeyPrivate from WIF/hex format of private key.
     * @param {string} privateKeyWif    Private key in WIF(hex) (Wallet Import Format) format.
     * @returns {KeyPrivate}            KeyPrivate instance.
     */
    KeyPrivate.fromWif = function (privateKeyWif) {
        var pKey = helpers_1.dcorejs_lib.PrivateKey.fromWif(privateKeyWif);
        return new KeyPrivate(pKey);
    };
    Object.defineProperty(KeyPrivate.prototype, "key", {
        /**
         * Raw representation of key for dcorejs_libjs
         * library purposes.
         * @return {any}
         */
        get: function () {
            return this._privateKey;
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(KeyPrivate.prototype, "stringKey", {
        /**
         * WIF format string representation of key
         * @return {string}
         */
        get: function () {
            return this._privateKey.toWif();
        },
        enumerable: true,
        configurable: true
    });
    /**
     * Get public key for private key.
     * @returns {KeyPublic}     KeyPublic instance.
     */
    KeyPrivate.prototype.getPublicKey = function () {
        return new KeyPublic(this._privateKey.toPublicKey());
    };
    return KeyPrivate;
}());
exports.KeyPrivate = KeyPrivate;
/**
 * PKI public key
 */
var KeyPublic = /** @class */ (function () {
    function KeyPublic(publicKey) {
        this._publicKey = publicKey;
    }
    /**
     * Create KeyPublic object from public key string.
     * @param {string} publicString     Public key string.
     * @returns {KeyPublic}             KeyPublic instance.
     */
    KeyPublic.fromString = function (publicString) {
        var pubKey = helpers_1.dcorejs_lib.PublicKey.fromPublicKeyString(publicString);
        return new KeyPublic(pubKey);
    };
    /**
     * Create KeyPublic from KeyPrivate object.
     * @param {KeyPrivate} privateKey   KeyPrivate object.
     * @returns {KeyPublic}             KeyPublic instance.
     */
    KeyPublic.fromPrivateKey = function (privateKey) {
        var publicKey = privateKey.key.toPublicKey();
        return new KeyPublic(publicKey);
    };
    Object.defineProperty(KeyPublic.prototype, "key", {
        /**
         * Raw representation of key for dcorejs_libjs
         * library purposes.
         * @return {any}
         */
        get: function () {
            return this._publicKey;
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(KeyPublic.prototype, "stringKey", {
        /**
         * String representation of key
         * @return {string}     String public key.
         */
        get: function () {
            return this._publicKey.toString();
        },
        enumerable: true,
        configurable: true
    });
    return KeyPublic;
}());
exports.KeyPublic = KeyPublic;
var ElGamalKeys = /** @class */ (function () {
    function ElGamalKeys(elGPrivateKey, elGPublicKey) {
        this._privateKey = elGPrivateKey;
        this._publicKey = elGPublicKey;
    }
    Object.defineProperty(ElGamalKeys.prototype, "privateKey", {
        get: function () {
            return this._privateKey;
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(ElGamalKeys.prototype, "publicKey", {
        get: function () {
            return this._publicKey;
        },
        enumerable: true,
        configurable: true
    });
    /**
     * Generate ElGamalKeys object from public key WIF.
     * @param {string} privateKey       Private key in WIF(hex) (Wallet Import Format) format
     * @returns {ElGamalKeys}           ElGamalKeys instance.
     */
    ElGamalKeys.generate = function (privateKey) {
        var elGPrivate = Utils.elGamalPrivate(privateKey);
        var elGPub = Utils.elGamalPublic(elGPrivate);
        return new ElGamalKeys(elGPrivate, elGPub);
    };
    return ElGamalKeys;
}());
exports.ElGamalKeys = ElGamalKeys;
var Utils = /** @class */ (function () {
    function Utils() {
    }
    /**
     * Format DCT price amount from blockchain format to real and readable formatted string.
     *
     * Example: Amount price from blockchain is 1, formatted price 0.00000001 DCT
     *
     * @param {number} dctAmount    Amount of DCT asset.
     * @return {string}             Formatted amount in string format.
     */
    Utils.formatToReadiblePrice = function (dctAmount) {
        return (dctAmount / chain_1.ChainApi.DCTPower).toFixed(8);
    };
    /**
     * Formats amount to DCT precision.
     * Value is devided by asset's precision factor
     * Note: Most of amount values are already formatted for this precision format.
     *
     * @param {number} amount   Amount to be formatted.
     * @returns {number}        DCore formatted amount.
     */
    Utils.formatAmountForDCTAsset = function (amount) {
        return amount / chain_1.ChainApi.DCTPower;
    };
    /**
     * Formats amount to format with decimal numbers.
     * Note: Most of amount values are already formatted for this precision format.
     *
     * @param {number} amount               Amount of asset in DCore network format.
     * @param {DCoreAssetObject} asset      Asset object to format amount to.
     * @returns {number}                    Formatted number in format with decimal numbers.
     */
    Utils.formatAmountForAsset = function (amount, asset) {
        return amount / Math.pow(10, asset.precision);
    };
    /**
     * Format amount value for DCore, to format without decimal numbers.
     *
     * @param {number} amount           Amount with decimal numbers to format.
     * @param {DCoreAssetObject} asset  Asset object for formatting.
     * @returns {number}                Formatted number.
     */
    Utils.formatAmountToAsset = function (amount, asset) {
        var transformedAmount = amount * Math.pow(10, asset.precision);
        return Number(transformedAmount.toFixed(0));
    };
    /**
     * RIPEMD 160 hash
     *
     * @param {Buffer} fromBuffer       Buffer to calculate hash from.
     * @returns {string}                RIPEMD160 hash.
     */
    Utils.ripemdHash = function (fromBuffer) {
        return crypt_1.CryptoUtils.ripemdHash(fromBuffer);
    };
    /**
     * Generate private and public key from given brain key.
     *
     * @param {string} fromBrainKey                                     Brain key to generate keys from.
     * @return {any[]} [privateKey: KeyPrivate, publicKey: KeyPublic]   Keys.
     */
    Utils.generateKeys = function (fromBrainKey) {
        var normalizedBk = Utils.normalize(fromBrainKey);
        var pkey = KeyPrivate.fromBrainKey(normalizedBk);
        var pubKey = KeyPublic.fromPrivateKey(pkey);
        return [pkey, pubKey];
    };
    /**
     * Calculate public key from given private key.
     *
     * @param {KeyPrivate} privkey      Private key to get public key for.
     * @return {KeyPublic}              KeyPublic object.
     */
    Utils.getPublicKey = function (privateKey) {
        return KeyPublic.fromPrivateKey(privateKey);
    };
    /**
     * Create KeyPrivate object from WIF format of private key.
     *
     * @param {string} pkWif    Private key in WIF(hex) (Wallet Import Format) format.
     * @return {KeyPrivate}     KeyPrivate object.
     */
    Utils.privateKeyFromWif = function (pkWif) {
        return KeyPrivate.fromWif(pkWif);
    };
    /**
     * Create KeyPublic object from string format of public key.
     *
     * @param {string} pubKeyString     Public key string.
     * @return {KeyPublic}              KeyPublic object.
     */
    Utils.publicKeyFromString = function (pubKeyString) {
        return KeyPublic.fromString(pubKeyString);
    };
    /**
     * Get random brain key.
     * https://docs.decent.ch/developer/group___wallet_a_p_i___account.html#ga4841362854805ef897b8415eb8866424
     *
     * @returns {string}    Brain key string.
     */
    Utils.suggestBrainKey = function () {
        return helpers_1.dcorejs_lib.key.suggest_brain_key(dictionary_1.dictionary.en.join(','));
    };
    /**
     * Get brainkey info with brain key, private key and public key.
     * https://docs.decent.ch/developer/group___wallet_a_p_i___account.html#ga1cca4c087c272e07681b2c6d203b7d74
     *
     * @param {string} brainKey     Brain keys string.
     * @returns {BrainKeyInfo}      BrainKeyInfo object.
     */
    Utils.getBrainKeyInfo = function (brainKey) {
        var normalizedBK = Utils.normalize(brainKey);
        var keys = Utils.generateKeys(normalizedBK);
        var result = {
            brain_priv_key: normalizedBK,
            pub_key: keys[1].stringKey,
            wif_priv_key: keys[0].stringKey
        };
        return result;
    };
    /**
     * Normalize brain key for futher usage in Utils's methods
     *
     * @param {string} brainKey         Brain key generated from Utils.suggestBrainKey or from wallet CLI
     * @returns {string}                Normalized brain key
     */
    Utils.normalize = function (brainKey) {
        if (typeof brainKey !== 'string') {
            throw new Error('string required for brainKey');
        }
        brainKey = brainKey.trim();
        brainKey = brainKey.toUpperCase();
        return brainKey.split(/[\t\n\v\f\r ]+/).join(' ');
    };
    /**
     * Generate random
     * @returns {string}
     */
    Utils.generateNonce = function () {
        return helpers_1.dcorejs_lib.TransactionHelper.unique_nonce_uint64();
    };
    /**
     * Generates El Gamal public key from given El Gamal private key
     *
     * @param {string} elGamalPrivate   El Gamal private key string.
     * @returns {string}                ElGamal public key string.
     */
    Utils.elGamalPublic = function (elGamalPrivate) {
        var elgPriv = BigInteger(elGamalPrivate);
        var modulus = BigInteger('11760620558671662461946567396662025495126946227619472274' +
            '601251081547302009186313201119191293557856181195016058359990840577430081932807832465057884143546419');
        var generator = BigInteger(3);
        return generator.modPow(elgPriv, modulus).toString();
    };
    /**
     * Generates El Gamal key for content exchange from given private key WIF string
     *
     * @param {string} privateKeyWif        WIF formatted private key of account for which generating El Gamal key
     * @returns {string}                    El Gamal private key string.
     */
    Utils.elGamalPrivate = function (privateKeyWif) {
        var pKey = Utils.privateKeyFromWif(privateKeyWif);
        var hash = js_sha512_1.sha512(pKey.key.d.toBuffer());
        return BigInteger(hash, 16).toString();
    };
    /**
     * Calculate El Gamal keys pair from WIF private key
     * @param {string} privateKeyWif    WIF formatted private key of account for which generating El Gamal keys
     * @returns {ElGamalKeys}           ElGamalKeys object.
     */
    Utils.generateElGamalKeys = function (privateKeyWif) {
        return ElGamalKeys.generate(privateKeyWif);
    };
    /**
     * Generate random brain key and El Gamal keys from brain key.
     *
     * @returns {[BrainKeyInfo , ElGamalKeys]}
     */
    Utils.generateBrainKeyElGamalKey = function () {
        var brainKey = Utils.suggestBrainKey();
        var bkInfo = Utils.getBrainKeyInfo(brainKey);
        var elGamalKeys = Utils.generateElGamalKeys(bkInfo.wif_priv_key);
        return [bkInfo, elGamalKeys];
    };
    /**
     * Calculate derived private key apart from primary(with sequence number 0).
     * NOTE: May be used as additional keys when creating account - owner, memo key
     *
     * @param {string} brainKey     Brain key string.
     * @param {number} sequence     Sequence number to derive private key from it. If selected 0, primary private key is generated.
     * @returns {KeyPrivate}        KeyPrivate object.
     */
    Utils.derivePrivateKey = function (brainKey, sequence) {
        return KeyPrivate.fromBrainKey(brainKey, sequence);
    };
    return Utils;
}());
exports.Utils = Utils;
//# sourceMappingURL=utils.js.map