"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
/**
 * @module DCore
 */
var helpers_1 = require("./helpers");
var content_1 = require("./modules/content");
var chain_1 = require("./api/chain");
var database_1 = require("./api/database");
var account_1 = require("./modules/account");
var history_1 = require("./api/history");
var apiConnector_1 = require("./api/apiConnector");
var asset_1 = require("./modules/asset");
var explorer_1 = require("./modules/explorer");
var mining_1 = require("./modules/mining");
var subscription_1 = require("./modules/subscription");
var seeding_1 = require("./modules/seeding");
var proposal_1 = require("./modules/proposal");
var transactionBuilder_1 = require("./transactionBuilder");
var messaging_1 = require("./api/messaging");
var messaging_2 = require("./modules/messaging");
var _content;
var _account;
var _explorer;
var _assetModule;
var _mining;
var _subscription;
var _seeding;
var _proposal;
var _chain;
var _transactionBuilder;
var _messaging;
var _connector;
var DcoreError = /** @class */ (function () {
    function DcoreError() {
    }
    DcoreError.app_not_initialized = 'app_not_initialized';
    DcoreError.app_missing_config = 'app_missing_config';
    return DcoreError;
}());
exports.DcoreError = DcoreError;
/**
 * Intialize dcorejs library with custom data that are used for library operations
 *
 * @param {DcoreConfig} config                                                  Configuration of dcore network yout about to connect to
 * @param {(state: ConnectionState) => void} [connectionStatusCallback=null]    Status callback to handle connection
 */
function initialize(config, testConnection, connectionStatusCallback) {
    if (testConnection === void 0) { testConnection = true; }
    if (connectionStatusCallback === void 0) { connectionStatusCallback = null; }
    var dcore = helpers_1.getLibRef();
    chain_1.ChainApi.setupChain(config.chainId, dcore.ChainConfig);
    _connector = new apiConnector_1.ApiConnector(config.dcoreNetworkWSPaths, dcore.Apis, testConnection, connectionStatusCallback);
    var database = new database_1.DatabaseApi(dcore.Apis, _connector);
    var historyApi = new history_1.HistoryApi(dcore.Apis, _connector);
    var messagingApi = new messaging_1.MessagingApi(dcore.Apis, _connector);
    _chain = new chain_1.ChainApi(_connector, dcore.ChainStore);
    _content = new content_1.ContentModule(database, _chain, _connector);
    _account = new account_1.AccountModule(database, _chain, historyApi, _connector);
    _explorer = new explorer_1.ExplorerModule(database);
    _assetModule = new asset_1.AssetModule(database, _connector, _chain);
    _subscription = new subscription_1.SubscriptionModule(database, _connector);
    _seeding = new seeding_1.SeedingModule(database);
    _mining = new mining_1.MiningModule(database, _connector, _chain);
    _proposal = new proposal_1.ProposalModule(database, _chain, _connector);
    _transactionBuilder = new transactionBuilder_1.TransactionBuilder();
    _messaging = new messaging_2.MessagingModule(database, messagingApi);
}
exports.initialize = initialize;
/**
 * Subscribe for blockchain update notifications. Notifications is fired periodically.
 *
 * @param {(data: any[]) => void} callback
 */
function subscribe(callback) {
    _chain.subscribe(callback);
}
exports.subscribe = subscribe;
function subscribeBlockApplied(callback) {
    _chain.subscribeBlockApplied(callback);
}
exports.subscribeBlockApplied = subscribeBlockApplied;
/**
 * Subscribe for events fired everytime new transaction is broadcasted to network
 *
 * @param callback
 */
function subscribePendingTransaction(callback) {
    _chain.subscribePendingTransactions(callback);
}
exports.subscribePendingTransaction = subscribePendingTransaction;
function content() {
    return _content;
}
exports.content = content;
function account() {
    return _account;
}
exports.account = account;
function explorer() {
    return _explorer;
}
exports.explorer = explorer;
function asset() {
    return _assetModule;
}
exports.asset = asset;
function mining() {
    return _mining;
}
exports.mining = mining;
function subscription() {
    return _subscription;
}
exports.subscription = subscription;
function seeding() {
    return _seeding;
}
exports.seeding = seeding;
function proposal() {
    return _proposal;
}
exports.proposal = proposal;
function messaging() {
    return _messaging;
}
exports.messaging = messaging;
function transactionBuilder() {
    _transactionBuilder = new transactionBuilder_1.TransactionBuilder();
    return _transactionBuilder;
}
exports.transactionBuilder = transactionBuilder;
function connection() {
    return _connector;
}
exports.connection = connection;
//# sourceMappingURL=dcore.js.map