"use strict";
var __extends = (this && this.__extends) || (function () {
    var extendStatics = Object.setPrototypeOf ||
        ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||
        function (d, b) { for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p]; };
    return function (d, b) {
        extendStatics(d, b);
        function __() { this.constructor = d; }
        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
    };
})();
Object.defineProperty(exports, "__esModule", { value: true });
/**
 * @module AccountModule
 */
var account_1 = require("../model/account");
var chain_1 = require("../api/chain");
var crypt_1 = require("../crypt");
var transactionBuilder_1 = require("../transactionBuilder");
var utils_1 = require("../utils");
var history_1 = require("../api/history");
var database_1 = require("../api/model/database");
var transaction_1 = require("../model/transaction");
var ApiModule_1 = require("./ApiModule");
var chain_2 = require("../api/model/chain");
var AccountOrder;
(function (AccountOrder) {
    AccountOrder["nameAsc"] = "+name";
    AccountOrder["idAsc"] = "+id";
    AccountOrder["nameDesc"] = "-name";
    AccountOrder["idDesc"] = "-id";
    AccountOrder["none"] = "";
})(AccountOrder = exports.AccountOrder || (exports.AccountOrder = {}));
/**
 * AccountModule is class that provides methods to obtain information from DCore node's Account module API.
 */
var AccountModule = /** @class */ (function (_super) {
    __extends(AccountModule, _super);
    function AccountModule(dbApi, chainApi, historyApi, apiConnector) {
        return _super.call(this, {
            dbApi: dbApi,
            apiConnector: apiConnector,
            historyApi: historyApi,
            chainApi: chainApi
        }) || this;
    }
    /**
     * Gets account from DCore blockchain database for given account name.
     * https://docs.decent.ch/developer/classgraphene_1_1app_1_1database__api__impl.html#ac5c1fd29358dcde88ec644292de59304
     *
     * @param {string} name         Account name. Example: "u123456789abcdef123456789"
     * @return {Promise<Account>}   Account object.
     */
    AccountModule.prototype.getAccountByName = function (name) {
        var _this = this;
        var dbOperation = new database_1.DatabaseOperations.GetAccountByName(name);
        return new Promise(function (resolve, reject) {
            _this.dbApi.execute(dbOperation)
                .then(function (account) {
                resolve(account);
            })
                .catch(function (err) {
                reject(_this.handleError(account_1.AccountError.account_fetch_failed, err));
            });
        });
    };
    /**
     * Gets account from DCore blockchain database for given account id.
     * https://docs.decent.ch/developer/classgraphene_1_1app_1_1database__api__impl.html#aa20a30ec92c339c1b186c4ee7825f67b
     *
     * @param {string} id           Account id in format '1.2.X'. Example: "1.2.345"
     * @return {Promise<Account>}   Account object.
     */
    AccountModule.prototype.getAccountById = function (id) {
        var _this = this;
        var dbOperation = new database_1.DatabaseOperations.GetAccounts([id]);
        return new Promise(function (resolve, reject) {
            _this.dbApi.execute(dbOperation)
                .then(function (accounts) {
                if (accounts.length === 0) {
                    reject(_this.handleError(account_1.AccountError.account_does_not_exist, "" + id));
                }
                var account = accounts[0];
                resolve(account);
            })
                .catch(function (err) {
                reject(_this.handleError(account_1.AccountError.account_fetch_failed, err));
            });
        });
    };
    /**
     * Gets history of transfer transaction for given account name.
     * https://docs.decent.ch/developer/classgraphene_1_1app_1_1database__api__impl.html#a180dc12024aa0e60bcbdf781611680fc
     *
     * @deprecated This method will be removed in future DCore update. Use getAccountHistory or searchAccountHistory instead
     *
     * @param {string} accountId                Account id in format '1.2.X'. Example: "1.2.345"
     * @param {string} order                    Order of TransactionRecords in result. Default is .timeDesc.
     * @param {string[]} privateKeys            Array of private keys in case private/public pair has been changed in blockchain account,
     *                                          using for example cli_wallet, to be able of decrypt older memo messages from transactions.
     * @param {string} startObjectId            Id of TransactionRecord to start search from for paging purposes. Default 0.0.0
     * @param {number} resultLimit              Number of transaction history records in result. Use for paging. Default 100(max)
     * @return {Promise<TransactionRecord[]>}   List of TransactionRecord.List of TransactionRecord.
     */
    AccountModule.prototype.getTransactionHistory = function (accountId, privateKeys, order, startObjectId, resultLimit) {
        var _this = this;
        if (order === void 0) { order = database_1.SearchAccountHistoryOrder.timeDesc; }
        if (startObjectId === void 0) { startObjectId = '0.0.0'; }
        if (resultLimit === void 0) { resultLimit = 100; }
        return new Promise(function (resolve, reject) {
            _this.searchAccountHistory(accountId, privateKeys, order, startObjectId, resultLimit)
                .then(function (transactions) {
                resolve(transactions);
            })
                .catch(function (err) {
                reject(_this.handleError(account_1.AccountError.transaction_history_fetch_failed, err));
            });
        });
    };
    /**
     * Returns transfer operations for given account.
     * https://docs.decent.ch/developer/classgraphene_1_1app_1_1database__api__impl.html#a180dc12024aa0e60bcbdf781611680fc
     *
     * @param {string} accountId                Account id in format '1.2.X'. Example: "1.2.345"
     * @param {string[]} privateKeys            Array of private keys in case private/public pair has been changed in blockchain account,
     *                                          using for example cli_wallet, to be able of decrypt older memo messages from transactions.
     * @param {string} order                    Order of TransactionRecords in result. Default is .timeDesc.
     * @param {string} startObjectId            Id of TransactionRecord to start search from for paging purposes. Default 0.0.0
     * @param {number} resultLimit              Number of transaction history records in result. Use for paging. Default 100(max)
     * @param {boolean} convertAssets           Optional parameter to convert amounts and fees of TransactionRecords from blockchain asset
     *                                          amount format to right precision format of asset. Example: 100000000 => 1 DCT.
     *                                          Default: false.
     * @returns {Promise<TransactionRecord[]>}  List of TransactionRecord.
     */
    AccountModule.prototype.searchAccountHistory = function (accountId, privateKeys, order, startObjectId, resultLimit, convertAssets) {
        var _this = this;
        if (order === void 0) { order = database_1.SearchAccountHistoryOrder.timeDesc; }
        if (startObjectId === void 0) { startObjectId = '0.0.0'; }
        if (resultLimit === void 0) { resultLimit = 100; }
        if (convertAssets === void 0) { convertAssets = false; }
        return new Promise(function (resolve, reject) {
            var dbOperation = new database_1.DatabaseOperations.SearchAccountHistory(accountId, order, startObjectId, resultLimit);
            _this.dbApi.execute(dbOperation)
                .then(function (transactions) {
                var listAssetsOp = new database_1.DatabaseOperations.ListAssets('', 100);
                _this.dbApi.execute(listAssetsOp)
                    .then(function (assets) {
                    var namePromises = [];
                    var res = transactions.map(function (tr) {
                        var transaction = new account_1.TransactionRecord(tr, privateKeys);
                        namePromises.push(new Promise(function (resolve, reject) {
                            _this.getAccountById(transaction.fromAccountId)
                                .then(function (account) {
                                transaction.fromAccountName = account.name;
                                resolve();
                            })
                                .catch(function (err) { return reject(_this.handleError(account_1.AccountError.account_fetch_failed, err)); });
                        }));
                        namePromises.push(new Promise(function (resolve, reject) {
                            _this.getAccountById(transaction.toAccountId)
                                .then(function (account) {
                                transaction.toAccountName = account.name;
                                resolve();
                            })
                                .catch(function (err) { return reject(_this.handleError(account_1.AccountError.account_fetch_failed, err)); });
                        }));
                        if (convertAssets) {
                            var asset = assets.find(function (a) { return a.id === transaction.transactionAsset; });
                            var feeAsset = assets.find(function (a) { return a.id === transaction.transactionFeeAsset; });
                            transaction.transactionAmount = utils_1.Utils.formatAmountForAsset(transaction.transactionAmount, asset);
                            transaction.transactionFee = utils_1.Utils.formatAmountForAsset(transaction.transactionFee, feeAsset);
                        }
                        return transaction;
                    });
                    Promise.all(namePromises)
                        .then(function () {
                        resolve(res);
                    })
                        .catch(function (err) { return reject(_this.handleError(account_1.AccountError.account_fetch_failed, err)); });
                });
            })
                .catch(function (err) {
                reject(_this.handleError(account_1.AccountError.transaction_history_fetch_failed, err));
            });
        });
    };
    /**
     * Transfers amount of asset between accounts.
     * https://docs.decent.ch/developer/group___wallet_a_p_i___account.html#gae61c0c78134741c534967260c8ff8a71
     *
     * @param {number} amount           Amount of asset to be send to receiver.
     * @param {string} assetId          Id of asset that amount will be sent in. If empty, default 1.3.0 - DCT is selected
     * @param {string} fromAccount      Name or id of sender account
     * @param {string} toAccount        Name or id of receiver account
     * @param {string} memo             Message for recipient
     * @param {string} privateKey       Private key used to encrypt memo and sign transaction
     * @return {Promise<Operation>}     Value confirming successful transaction broadcasting.
     */
    AccountModule.prototype.transfer = function (amount, assetId, fromAccount, toAccount, memo, privateKey, broadcast) {
        var _this = this;
        if (broadcast === void 0) { broadcast = true; }
        var pKey = utils_1.Utils.privateKeyFromWif(privateKey);
        return new Promise(function (resolve, reject) {
            if (memo && !privateKey) {
                reject(account_1.AccountError.transfer_missing_pkey);
            }
            var methods = [].concat(new chain_2.ChainMethods.GetAccount(fromAccount), new chain_2.ChainMethods.GetAccount(toAccount), new chain_2.ChainMethods.GetAsset(assetId || '1.3.0'));
            (_a = _this.chainApi).fetch.apply(_a, methods).then(function (result) {
                var senderAccount = result[0], receiverAccount = result[1], asset = result[2];
                if (!senderAccount) {
                    reject(_this.handleError(account_1.AccountError.transfer_sender_account_not_found, "" + fromAccount));
                }
                if (!receiverAccount) {
                    reject(_this.handleError(account_1.AccountError.transfer_receiver_account_not_found, "" + toAccount));
                }
                var nonce = chain_1.ChainApi.generateNonce();
                var fromPublicKey = senderAccount.get('options').get('memo_key');
                var toPublicKey = receiverAccount.get('options').get('memo_key');
                var pubKey = utils_1.Utils.publicKeyFromString(toPublicKey);
                var memo_object = {
                    from: fromPublicKey,
                    to: toPublicKey,
                    nonce: nonce,
                    message: crypt_1.CryptoUtils.encryptWithChecksum(memo, pKey, pubKey, nonce)
                };
                var assetObject = JSON.parse(JSON.stringify(asset));
                var transaction = new transactionBuilder_1.TransactionBuilder();
                var transferOperation = new transaction_1.Operations.TransferOperation(senderAccount.get('id'), receiverAccount.get('id'), account_1.Asset.create(amount, assetObject), memo_object);
                var added = transaction.addOperation(transferOperation);
                if (added === '') {
                    if (broadcast) {
                        transaction.broadcast(privateKey)
                            .then(function () {
                            resolve(transaction.operations[0]);
                        })
                            .catch(function (err) {
                            reject(_this.handleError(account_1.AccountError.transaction_broadcast_failed, err));
                            return;
                        });
                    }
                    else {
                        resolve(transaction.operations[0]);
                    }
                }
                else {
                    reject(_this.handleError(account_1.AccountError.syntactic_error, added));
                    return;
                }
            })
                .catch(function (err) { return reject(_this.handleError(account_1.AccountError.account_fetch_failed, err)); });
            var _a;
        });
    };
    /**
     * Current account balance of asset on given account
     * https://docs.decent.ch/developer/classgraphene_1_1app_1_1database__api__impl.html#a52515490f739d3523c9d842e2e2362ef
     *
     * @param {string} accountId        Account id in format '1.2.X'. Example: '1.2.345'
     * @param {string} assetId          Id of asset in which balance will be listed
     * @param {boolean} convertAsset    Optional parameter to convert balance amount from blockchain asset
                                        amount format to right precision format of asset. Example: 100000000 => 1 DCT.
     *                                  Default: false.
     * @return {Promise<number>}        Account's balance
     */
    AccountModule.prototype.getBalance = function (accountId, assetId, convertAsset) {
        var _this = this;
        if (assetId === void 0) { assetId = '1.3.0'; }
        if (convertAsset === void 0) { convertAsset = false; }
        return new Promise(function (resolve, reject) {
            if (!accountId) {
                reject('missing_parameter');
                return;
            }
            var getAssetOp = new database_1.DatabaseOperations.GetAssets([assetId || '1.3.0']);
            _this.dbApi.execute(getAssetOp)
                .then(function (assets) {
                if (!assets || assets.length === 0) {
                    reject(_this.handleError(database_1.DatabaseError.asset_fetch_failed));
                    return;
                }
                var asset = assets[0];
                var dbOperation = new database_1.DatabaseOperations.GetAccountBalances(accountId, [asset.id]);
                _this.dbApi.execute(dbOperation)
                    .then(function (balances) {
                    if (!balances || !balances[0]) {
                        reject(_this.handleError(account_1.AccountError.asset_does_not_exist));
                        return;
                    }
                    var balance = balances[0];
                    resolve(convertAsset ? utils_1.Utils.formatAmountForAsset(balance.amount, asset) : Number(balance.amount));
                })
                    .catch(function (err) {
                    reject(_this.handleError(account_1.AccountError.database_operation_failed, err));
                });
            })
                .catch(function (err) { return _this.handleError(database_1.DatabaseError.database_execution_failed, err); });
        });
    };
    /**
     * Verifies if block in that transaction was processed to is irreversible.
     * NOTE: Unverified blocks still can be reversed.
     *
     * NOTICE:
     * Transaction object with id in form '1.7.X' can be fetched from AccountModule.getAccountHistory method.
     *
     * @param {string} accountId        Account id in format '1.2.X'. Example: '1.2.30'
     * @param {string} transactionId    Transaction id in format '1.7.X'.
     * @return {Promise<boolean>}       Returns 'true' if transaction is in irreversible block, 'false' otherwise.
     */
    AccountModule.prototype.isTransactionConfirmed = function (accountId, transactionId) {
        var _this = this;
        return new Promise(function (resolve, reject) {
            var start = transactionId;
            if (transactionId !== '1.7.0') {
                var trNumSplit = transactionId.split('.');
                trNumSplit[2] = "" + (Number(trNumSplit[2]) - 1);
                start = trNumSplit.join('.');
            }
            else {
                reject(_this.handleError(account_1.AccountError.bad_parameter, ''));
            }
            var operation = new history_1.HistoryOperations.GetAccountHistory(accountId, start, transactionId);
            _this.historyApi.execute(operation)
                .then(function (res) {
                if (res.length === 0) {
                    reject(_this.handleError(account_1.AccountError.transaction_history_fetch_failed, 'No transactions found'));
                }
                var dbOp = new database_1.DatabaseOperations.GetDynamicGlobalProperties();
                _this.dbApi.execute(dbOp)
                    .then(function (props) {
                    resolve(res[0].block_num <= props.last_irreversible_block_num);
                })
                    .catch(function (err) { return reject(_this.handleError(account_1.AccountError.database_operation_failed, err)); });
            })
                .catch(function (err) { return reject(_this.handleError(account_1.AccountError.history_fetch_failed, err)); });
        });
    };
    /**
     * List of all transaction operations in history of user.
     * NOTE: Operations can be filtered using Chain.ChainOperationType
     * https://docs.decent.ch/developer/group___history_a_p_i.html#ga2bfce814ce4adde1c30e63662f3fa18c
     *
     * @param {string} accountId                Account id in format '1.2.X'. Example: '1.2.345'
     * @param historyOptions                    Optional HistoryOptions object to configure fromId and resultLimit for paging.
     *                                          fromId: Id of HistoryRecord from what to start list from. Default: '1.7.0'
     *                                          resultLimit: Number of HistoryRecords in result. Default: 100(Max)
     *                                          NOTE: List is in DESC order. Therefore fromId of operation suppose to be last in received
     *                                          list.
     * @return {Promise<HistoryRecord[]>}       List of HistoryRecord objects.
     */
    AccountModule.prototype.getAccountHistory = function (accountId, historyOptions) {
        var _this = this;
        return new Promise(function (resolve, reject) {
            var operation = new history_1.HistoryOperations.GetAccountHistory(accountId, '1.7.0', historyOptions && historyOptions.fromId || '1.7.0', historyOptions && historyOptions.resultLimit || 100);
            _this.historyApi.execute(operation)
                .then(function (res) {
                resolve(res);
            })
                .catch(function (err) { return reject(_this.handleError(account_1.AccountError.transaction_history_fetch_failed, err)); });
        });
    };
    /**
     * Search accounts based on given search parameters.
     * https://docs.decent.ch/developer/classgraphene_1_1app_1_1database__api__impl.html#a57cbf9b3e799ea70b08885cc5df9b043
     *
     * @param {string} searchTerm   Term to search in account names. Default: ''
     * @param {string} order        AccountOrder to order results. Default: AccountOrder.none
     * @param {string} id           Account id to start list from. Default: '0.0.0'
     * @param {number} limit        Limit result list size. Default: 100(Max)
     * @returns {Promise<Account>}  List of filtered accounts.
     */
    AccountModule.prototype.searchAccounts = function (searchTerm, order, id, limit) {
        var _this = this;
        if (searchTerm === void 0) { searchTerm = ''; }
        if (order === void 0) { order = AccountOrder.none; }
        if (id === void 0) { id = '0.0.0'; }
        if (limit === void 0) { limit = 100; }
        return new Promise(function (resolve, reject) {
            var operation = new database_1.DatabaseOperations.SearchAccounts(searchTerm, order, id, limit);
            _this.dbApi.execute(operation)
                .then(function (res) { return resolve(res); })
                .catch(function (err) { return reject(err); });
        });
    };
    /**
     * Returns number of accounts created on network
     * https://docs.decent.ch/developer/classgraphene_1_1app_1_1database__api__impl.html#a533c834442d9e8fbaeae5eb24d4fe8c5
     *
     * @returns {Promise<number>}   Number of accounts.
     */
    AccountModule.prototype.getAccountCount = function () {
        var _this = this;
        return new Promise(function (resolve, reject) {
            var operation = new database_1.DatabaseOperations.GetAccountCount();
            _this.dbApi.execute(operation)
                .then(function (res) { return resolve(res); })
                .catch(function (err) { return reject(err); });
        });
    };
    /**
     * Creates new account in DCore blockchain network.
     * https://docs.decent.ch/developer/classgraphene_1_1wallet_1_1detail_1_1wallet__api__impl.html#aed56e5dfd4dc85b40d62dd25cb1fd029
     *
     * @param {string} name                 Name of newly created account.
     * @param {string} ownerKey             Public key to be used as owner key in WIF(hex)(Wallet Import Format) format.
     * @param {string} activeKey            Public key to be used as active key in WIF(hex)(Wallet Import Format) format.
     * @param {string} memoKey              Public key used to memo encryption in WIF(hex)(Wallet Import Format) format.
     * @param {string} registrar            Registrar account id who pay account creation transaction fee.
     * @param {string} regisrarPrivateKey   Registrar private key, in WIF(hex)(Wallet Import Format) format, for account register
     *                                      transaction to be signed with.
     * @returns {Promise<boolean>}          Value confirming successful transaction broadcasting.
     */
    AccountModule.prototype.registerAccount = function (name, ownerKey, activeKey, memoKey, registrar, registrarPrivateKey, broadcast) {
        var _this = this;
        if (broadcast === void 0) { broadcast = true; }
        var ownerKeyAuths = [];
        ownerKeyAuths.push([ownerKey, 1]);
        var activeKeyAuths = [];
        activeKeyAuths.push([activeKey, 1]);
        var owner = {
            weight_threshold: 1,
            account_auths: [],
            key_auths: ownerKeyAuths
        };
        var active = {
            weight_threshold: 1,
            account_auths: [],
            key_auths: activeKeyAuths
        };
        return new Promise(function (resolve, reject) {
            _this.apiConnector.connect()
                .then(function () {
                var operation = new transaction_1.Operations.RegisterAccount({
                    name: name,
                    owner: owner,
                    active: active,
                    registrar: registrar,
                    options: {
                        memo_key: memoKey,
                        voting_account: '1.2.3',
                        allow_subscription: false,
                        price_per_subscribe: account_1.Asset.createDCTAsset(0),
                        num_miner: 0,
                        votes: [],
                        extensions: [],
                        subscription_period: 0,
                    }
                });
                var transaction = new transactionBuilder_1.TransactionBuilder();
                var added = transaction.addOperation(operation);
                if (added === '') {
                    if (broadcast) {
                        transaction.broadcast(registrarPrivateKey)
                            .then(function () { return resolve(transaction.operations[0]); })
                            .catch(function (err) { return reject(err); });
                    }
                    else {
                        resolve(transaction.operations[0]);
                    }
                }
                else {
                    reject(_this.handleError(account_1.AccountError.syntactic_error, added));
                }
            })
                .catch(function (err) { return console.log(err); });
        });
    };
    /**
     * Create account in DCore blockchain network with keys derived from provided brain key.
     * https://docs.decent.ch/developer/classgraphene_1_1wallet_1_1detail_1_1wallet__api__impl.html#a758d05a5f090adbc249258881775d222
     *
     * NOTE: This method create account with owner, active and memo key set to same value.
     *       Recommended to use Utils.derivePrivateKey to derive keys from brainkey and then register account
     *       with option to set these keys to different values.
     *
     * @param {string} brainkey             Brain key for keys derivation. Use brain key from Utils.suggestBrainKey.
     * @param {string} accountName          Name for new account. String with alphanumerical symbols and dash. Example: 'new-account2'
     * @param {string} registrar            Registrar account id, who pay for account registration in format '1.2.X'. Example: '1.2.345'
     * @param {string} registrarPrivateKey  Registrar private key in WIF(hex)(Wallet Import Format) format.
     * @returns {Promise<boolean>}          Value confirming successful transaction broadcasting.
     */
    AccountModule.prototype.createAccountWithBrainkey = function (brainkey, accountName, registrar, registrarPrivateKey) {
        var normalizedBrainkey = utils_1.Utils.normalize(brainkey);
        var keyPair = utils_1.Utils.generateKeys(normalizedBrainkey);
        return this.registerAccount(accountName, keyPair[1].stringKey, keyPair[1].stringKey, keyPair[1].stringKey, registrar, registrarPrivateKey);
    };
    /**
     * Exports wallet-cli compatible wallet file.
     * https://docs.decent.ch/developer/classgraphene_1_1wallet_1_1detail_1_1wallet__api__impl.html#a3cb922b2d88865c509a8e2c91b7416ab
     *
     * @param {string} accountId            Account id that about to be exported, in format '1.2.X'. Example: '1.2.345'
     * @param {string} password             Password for keys structure encryption.
     * @param privateKeys                   Private keys, in WIF(hex)(Wallet Import Format) format, to be exported
     * @param additionalElGamalPrivateKeys  Additional el gamal keys, in case that has been changed over time. Primary el gamal key is
     *                                      calculated from privateKeys.
     * @returns {Promise<WalletExport>}     WalletExport object that can be serialized and used as import for cli_wallet.
     */
    AccountModule.prototype.exportWallet = function (accountId, password, privateKeys, additionalElGamalPrivateKeys) {
        var _this = this;
        if (additionalElGamalPrivateKeys === void 0) { additionalElGamalPrivateKeys = []; }
        return new Promise(function (resolve, reject) {
            _this.getAccountById(accountId)
                .then(function (acc) {
                if (!acc) {
                    reject(_this.handleError(account_1.AccountError.account_does_not_exist, ''));
                    return;
                }
                var elGamalKeys = privateKeys.map(function (pk) {
                    var elGPriv = utils_1.Utils.elGamalPrivate(pk);
                    var elGPub = utils_1.Utils.elGamalPublic(elGPriv);
                    return {
                        private: { s: elGPriv },
                        public: { s: elGPub }
                    };
                });
                elGamalKeys.push.apply(elGamalKeys, additionalElGamalPrivateKeys.map(function (elGPriv) {
                    var elGPub = utils_1.Utils.elGamalPublic(elGPriv);
                    return {
                        private: { s: elGPriv },
                        public: { s: elGPub }
                    };
                }));
                var walletExport = {
                    version: 1,
                    chain_id: _this.chainApi.chainId,
                    my_accounts: [acc],
                    cipher_keys: '',
                    extra_keys: [],
                    pending_account_registrations: [],
                    pending_miner_registrations: [],
                    ws_server: _this.apiConnector.apiAddresses[0],
                    ws_user: '',
                    ws_password: '',
                };
                var keys = {
                    ec_keys: privateKeys.map(function (pk) {
                        var pubKey = utils_1.Utils.getPublicKey(utils_1.Utils.privateKeyFromWif(pk));
                        return [pubKey.stringKey, pk];
                    }),
                    el_gamal_keys: elGamalKeys,
                    checksum: crypt_1.CryptoUtils.sha512(password)
                };
                walletExport.cipher_keys = crypt_1.CryptoUtils.encryptToHexString(JSON.stringify(keys), password);
                resolve(walletExport);
            })
                .catch(function (err) { return reject(_this.handleError(account_1.AccountError.database_operation_failed, err)); });
        });
    };
    /**
     * Fetch list of an accounts.
     * https://docs.decent.ch/developer/classgraphene_1_1app_1_1database__api__impl.html#abf203f3002c7e2053c33eb6cb4e147c6
     *
     * @param {string} loweBound                Account id from which accounts are listed, in format '1.2.X'. Default: ''
     * @param {number} limit                    Number of returned accounts. Default: 100(Max)
     * @returns {Promise<AccountNameIdPair>}    List of filtered AccountNameIdPairs.
     */
    AccountModule.prototype.listAccounts = function (lowerBound, limit) {
        var _this = this;
        if (lowerBound === void 0) { lowerBound = ''; }
        if (limit === void 0) { limit = 100; }
        return new Promise(function (resolve, reject) {
            var operation = new database_1.DatabaseOperations.LookupAccounts(lowerBound, limit);
            _this.dbApi.execute(operation)
                .then(function (res) { return resolve(res); })
                .catch(function (err) { return reject(_this.handleError(account_1.AccountError.database_operation_failed, err)); });
        });
    };
    /**
     * Returns account's balances in all assets account have non-zero amount in.
     * https://docs.decent.ch/developer/classgraphene_1_1app_1_1database__api__impl.html#a52515490f739d3523c9d842e2e2362ef
     *
     * @param {string} id               Account id in format '1.2.X', Example: '1.2.345'.
     * @param {boolean} convertAssets   Optional parameter to convert balance amount from blockchain asset
     *                                  amount format to right precision format of asset. Example: 100000000 => 1 DCT. Default: false.
     * @returns {Promise<Asset[]>}      List of balances
     */
    AccountModule.prototype.listAccountBalances = function (id, convertAssets) {
        var _this = this;
        if (convertAssets === void 0) { convertAssets = false; }
        return new Promise(function (resolve, reject) {
            var operation = new database_1.DatabaseOperations.GetAccountBalances(id, []);
            _this.dbApi.execute(operation)
                .then(function (balances) {
                if (balances.length === 0) {
                    resolve(balances);
                    return;
                }
                var listAssetsOp = new database_1.DatabaseOperations.GetAssets(balances.map(function (asset) { return asset.asset_id; }));
                _this.dbApi.execute(listAssetsOp)
                    .then(function (assets) {
                    if (!assets || assets.length === 0) {
                        reject(_this.handleError(account_1.AccountError.database_operation_failed));
                        return;
                    }
                    if (!convertAssets) {
                        resolve(balances);
                        return;
                    }
                    var result = [].concat.apply([], balances);
                    result.forEach(function (bal) {
                        var asset = assets.find(function (a) { return a.id === bal.asset_id; });
                        bal.amount = utils_1.Utils.formatAmountForAsset(bal.amount, asset);
                    });
                    resolve(result);
                })
                    .catch(function (err) { return reject(_this.handleError(account_1.AccountError.database_operation_failed, err)); });
            })
                .catch(function (err) { return reject(_this.handleError(account_1.AccountError.database_operation_failed, err)); });
        });
    };
    /**
     * Search for miners with parameters.
     * https://docs.decent.ch/developer/classgraphene_1_1wallet_1_1detail_1_1wallet__api__impl.html#a6bf2da2d8f11165c8990d3a849c2dd92
     *
     * @param {string} accountName          Account name to search miners for.
     * @param {string} keyword              Search keyword.
     * @param {boolean} myVotes             Flag to search within account's voted miners.
     * @param {MinerOrder} sort             Sorting parameter of search results.
     * @param {string} fromMinerId          Miner id to start form. Use for paging.
     * @param {number} limit                Result count. Default and max is 1000
     * @returns {Promise<MinerInfo[]>}      List of filtered MinerInfo objects.
     */
    AccountModule.prototype.searchMinerVoting = function (accountName, keyword, myVotes, sort, fromMinerId, limit) {
        var _this = this;
        if (myVotes === void 0) { myVotes = true; }
        if (sort === void 0) { sort = database_1.MinerOrder.none; }
        if (fromMinerId === void 0) { fromMinerId = ''; }
        if (limit === void 0) { limit = 1000; }
        return new Promise(function (resolve, reject) {
            var operation = new database_1.DatabaseOperations.SearchMinerVoting(accountName, keyword, myVotes, sort, fromMinerId, limit);
            _this.dbApi.execute(operation)
                .then(function (res) { return resolve(res); })
                .catch(function (err) {
                reject(_this.handleError(database_1.DatabaseError.database_execution_failed, err));
            });
        });
    };
    /**
     * Update account properties.
     * https://docs.decent.ch/developer/structgraphene_1_1wallet_1_1wallet__data.html#a7e45dcef220b45e13f0918b1036cbf41
     *
     * @param {string} accountId                Account id of account that is about to be updated. Example: '1.2.345'.
     * @param {UpdateAccountParameters} params  UpdateAccountParameters object with parameters to be changed.
     * @param {string} privateKey               Private key of account that is about to be changed, to sign transaction.
     *                                          In WIF(hex)(Wallet Import Format) format.
     * @returns {Promise<Boolean>}              Value confirming successful transaction broadcasting.
     */
    AccountModule.prototype.updateAccount = function (accountId, params, privateKey, broadcast) {
        var _this = this;
        if (broadcast === void 0) { broadcast = true; }
        return new Promise((function (resolve, reject) {
            _this.getAccountById(accountId)
                .then(function (account) {
                if (account === null) {
                    reject(_this.handleError(account_1.AccountError.account_does_not_exist));
                    return;
                }
                var ownerAuthority = Object.assign({}, account.owner);
                ownerAuthority.key_auths[0][0] = params.newOwnerKey || account.owner.key_auths[0][0];
                var activeAuthority = Object.assign({}, account.active);
                activeAuthority.key_auths[0][0] = params.newActiveKey || account.active.key_auths[0][0];
                var priceSubscription = Object.assign({}, account.options.price_per_subscribe);
                if (params.newSubscription !== undefined) {
                    priceSubscription = account_1.Asset.createDCTAsset(params.newSubscription.pricePerSubscribeAmount);
                }
                var newOptions = {
                    memo_key: params.newMemoKey || account.options.memo_key,
                    voting_account: account.options.voting_account,
                    num_miner: params.newNumMiner || account.options.num_miner,
                    votes: params.newVotes || account.options.votes,
                    extensions: account.options.extensions,
                    allow_subscription: params.newSubscription
                        ? params.newSubscription.allowSubscription
                        : account.options.allow_subscription,
                    price_per_subscribe: priceSubscription,
                    subscription_period: params.newSubscription
                        ? params.newSubscription.subscriptionPeriod
                        : account.options.subscription_period
                };
                var accountUpdateOperation = new transaction_1.Operations.AccountUpdateOperation(accountId, ownerAuthority, activeAuthority, newOptions, {});
                var transaction = new transactionBuilder_1.TransactionBuilder();
                var added = transaction.addOperation(accountUpdateOperation);
                if (added === '') {
                    if (broadcast) {
                        transaction.broadcast(privateKey)
                            .then(function () {
                            resolve(transaction.operations[0]);
                        })
                            .catch(function (error) {
                            reject(_this.handleError(account_1.AccountError.transaction_broadcast_failed, error));
                        });
                    }
                    else {
                        resolve(transaction.operations[0]);
                    }
                }
                else {
                    reject(_this.handleError(account_1.AccountError.syntactic_error, added));
                    return;
                }
            })
                .catch(function (error) {
                reject(_this.handleError(account_1.AccountError.account_update_failed, error));
            });
        }));
    };
    return AccountModule;
}(ApiModule_1.ApiModule));
exports.AccountModule = AccountModule;
//# sourceMappingURL=account.js.map