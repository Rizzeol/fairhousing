"use strict";
var __extends = (this && this.__extends) || (function () {
    var extendStatics = Object.setPrototypeOf ||
        ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||
        function (d, b) { for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p]; };
    return function (d, b) {
        extendStatics(d, b);
        function __() { this.constructor = d; }
        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
    };
})();
Object.defineProperty(exports, "__esModule", { value: true });
var chain_1 = require("../api/chain");
var transactionBuilder_1 = require("../transactionBuilder");
var util_1 = require("util");
var database_1 = require("../api/model/database");
var transaction_1 = require("../model/transaction");
var ApiModule_1 = require("./ApiModule");
var utils_1 = require("../utils");
var chain_2 = require("../api/model/chain");
var moment = require('moment');
var ContentError;
(function (ContentError) {
    ContentError["database_operation_failed"] = "operation_failed";
    ContentError["fetch_content_failed"] = "fetch_content_failed";
    ContentError["transaction_broadcast_failed"] = "transaction_broadcast_failed";
    ContentError["restore_content_keys_failed"] = "restore_content_keys_failed";
    ContentError["asset_fetch_failed"] = "asset_fetch_failed";
    ContentError["asset_not_found"] = "asset_not_found";
    ContentError["content_not_exist"] = "content_not_exist";
    ContentError["account_fetch_failed"] = "account_fetch_failed";
    ContentError["parameters_error"] = "parameters_error";
    ContentError["connection_failed"] = "connection_failed";
    ContentError["syntactic_error"] = "syntactic_error";
})(ContentError = exports.ContentError || (exports.ContentError = {}));
/**
 * ContentApi provide methods to communication
 * with content stored in DCore network.
 */
var ContentModule = /** @class */ (function (_super) {
    __extends(ContentModule, _super);
    function ContentModule(dbApi, chainApi, apiConnector) {
        return _super.call(this, {
            dbApi: dbApi,
            chainApi: chainApi,
            apiConnector: apiConnector
        }) || this;
    }
    /**
     * Searches content submitted to DCore network and is not expired.
     * https://docs.decent.ch/developer/classgraphene_1_1app_1_1database__api__impl.html#a4526e41a8bf7bc921072d11cec0c894c
     *
     * @param {SearchParams} searchParams       Parameters for content filtering.
     * @param {boolean} convertAsset            Optional parameter to convert amounts and fees of Content from blockchain asset
     *                                          amount format to right precision format of asset. Example: 100000000 => 1 DCT.
     *                                          Default: false.
     * @return {Promise<Content[]>}             List of Content object that conform search parameters.
     */
    ContentModule.prototype.searchContent = function (searchParams, convertAsset) {
        var _this = this;
        if (convertAsset === void 0) { convertAsset = false; }
        var dbOperation = new database_1.DatabaseOperations.SearchContent(searchParams);
        return new Promise(function (resolve, reject) {
            _this.dbApi
                .execute(dbOperation)
                .then(function (content) {
                var listAssetsOp = new database_1.DatabaseOperations.ListAssets('', 100);
                _this.dbApi.execute(listAssetsOp)
                    .then(function (assets) {
                    resolve(content.map(function (c) {
                        c.synopsis = JSON.parse(c.synopsis);
                        if (c.price && convertAsset) {
                            c = _this.formatPrices(c, assets);
                        }
                        return c;
                    }));
                })
                    .catch(function (err) { return console.log(err); });
            })
                .catch(function (err) {
                reject(_this.handleError(ContentError.database_operation_failed, err));
            });
        });
    };
    /**
     * Get content object from blockchain for given content id
     *
     * @param {string} id                   Id of content to get. Example: '2.13.345'
     * @param {boolean} convertAsset        Optional parameter to convert amounts and fees of Content from blockchain asset
     *                                      amount format to right precision format of asset. Example: 100000000 => 1 DCT.
     *                                      Default: false.
     * @return {Promise<Content | null>}    Content object.
     */
    ContentModule.prototype.getContent = function (id, convertAsset) {
        var _this = this;
        if (convertAsset === void 0) { convertAsset = false; }
        return new Promise(function (resolve, reject) {
            var listAssetsOp = new database_1.DatabaseOperations.ListAssets('', 100);
            _this.dbApi.execute(listAssetsOp)
                .then(function (assets) {
                var dbOperation = new database_1.DatabaseOperations.GetObjects([id]);
                _this.dbApi
                    .execute(dbOperation)
                    .then(function (contents) {
                    if (!contents || !contents[0]) {
                        resolve(null);
                        return;
                    }
                    var content = contents[0];
                    var stringidied = JSON.stringify(content);
                    var objectified = JSON.parse(stringidied);
                    objectified.synopsis = JSON.parse(objectified.synopsis);
                    if (util_1.isUndefined(objectified.price['amount']) && convertAsset) {
                        objectified = _this.formatPrices([objectified], assets)[0];
                    }
                    resolve(objectified);
                });
            })
                .catch(function (err) {
                reject(_this.handleError(ContentError.database_operation_failed, err));
            });
        });
    };
    /**
     * Get content with given URI.
     * https://docs.decent.ch/developer/classgraphene_1_1app_1_1database__api__impl.html#a1790db302a96536fe8be9794969fbfdb
     *
     * @param {string} URI                  Content URI
     * @param {boolean} convertAsset        Optional parameter to convert amounts and fees of Content from blockchain asset
     *                                      amount format to right precision format of asset. Example: 100000000 => 1 DCT.
     *                                      Default: false.
     * @returns {Promise<Content | null>}   Content object.
     */
    ContentModule.prototype.getContentURI = function (URI, convertAsset) {
        var _this = this;
        if (convertAsset === void 0) { convertAsset = false; }
        return new Promise(function (resolve, reject) {
            var listAssetsOp = new database_1.DatabaseOperations.ListAssets('', 100);
            _this.dbApi.execute(listAssetsOp)
                .then(function (assets) {
                var dbOperation = new database_1.DatabaseOperations.GetContent(URI);
                _this.dbApi
                    .execute(dbOperation)
                    .then(function (content) {
                    if (!content) {
                        resolve(null);
                        return;
                    }
                    var stringidied = JSON.stringify(content);
                    var objectified = JSON.parse(stringidied);
                    objectified.synopsis = JSON.parse(objectified.synopsis);
                    if (util_1.isUndefined(objectified.price['amount']) && convertAsset) {
                        objectified = _this.formatPrices([objectified], assets);
                    }
                    resolve(objectified);
                });
            })
                .catch(function (err) {
                reject(_this.handleError(ContentError.database_operation_failed, err));
            });
        });
    };
    /**
     * Cancel submitted content in blockchain.
     * https://docs.decent.ch/developer/classgraphene_1_1wallet_1_1detail_1_1wallet__api__impl.html#a51951fe58f271369898d529e537bf45e
     *
     * @param {string} contentId        Content id in format '2.13.X'. Example: '2.13.1234'
     * @param {string} authorId         Author id in format'1.2.X'. Example: '1.2.345'
     * @param {string} privateKey       Author's private key to submit transaction in WIF(hex) (Wallet Import Format) format.
     * @return {Promise<void>}          Value confirming successful transaction broadcasting.
     */
    ContentModule.prototype.removeContent = function (contentId, authorId, privateKey) {
        var _this = this;
        return new Promise(function (resolve, reject) {
            _this.getContent(contentId)
                .then(function (content) {
                var URI = content.URI;
                var cancelOperation = new transaction_1.Operations.ContentCancelOperation(authorId, URI);
                var transaction = new transactionBuilder_1.TransactionBuilder();
                var added = transaction.addOperation(cancelOperation);
                if (added === '') {
                    transaction.broadcast(privateKey)
                        .then(function () {
                        resolve();
                    })
                        .catch(function (err) {
                        reject(_this.handleError(ContentError.transaction_broadcast_failed, err));
                    });
                }
                else {
                    reject(_this.handleError(ContentError.syntactic_error, added));
                    return;
                }
            })
                .catch(function (err) {
                reject(_this.handleError(ContentError.fetch_content_failed, err));
            });
        });
    };
    /**
     * Restores key to decrypt downloaded content.
     *
     * ElGamalPrivate contains keys used to identify if user have bought content.
     * May contains older keys, if elGamal keys pair were changed,
     * to restore content bought before keys have been changed. Otherwise content keys
     * would not be restored.
     * https://docs.decent.ch/developer/group___database_a_p_i___decent.html#gaa952f1c2adc2781d42a3f457e2d18d09
     *
     * @param {string} contentId                Content id in format '2.13.X', Example: '2.13.453'
     * @param {string} accountId                Account if in format '1.2.X'. Example: '1.2.345'
     * @param {...string[]} elGamalKeys         El Gamal keys to identify that user bought content. May contains older keys, if el gamal
     *                                          keys pair were changed, to restore content bought before keys have been changed.
     *                                          Otherwise content keys would not be restored.
     * @returns {Promise<string>}               Content key to decrypt content.
     */
    ContentModule.prototype.restoreContentKeys = function (contentId, accountId) {
        var _this = this;
        var elGamalKeys = [];
        for (var _i = 2; _i < arguments.length; _i++) {
            elGamalKeys[_i - 2] = arguments[_i];
        }
        return new Promise(function (resolve, reject) {
            _this.getContent(contentId)
                .then(function (content) {
                var dbOperation = new database_1.DatabaseOperations.GetBuyingHistoryObjects(accountId, content.URI);
                _this.dbApi.execute(dbOperation)
                    .then(function (res) {
                    var validKey = elGamalKeys.find(function (elgPair) { return elgPair.publicKey === res.pubKey.s; });
                    if (!validKey) {
                        reject(_this.handleError(ContentError.restore_content_keys_failed, 'wrong keys'));
                    }
                    var dbOperation = new database_1.DatabaseOperations.RestoreEncryptionKey(contentId, validKey.privateKey);
                    _this.dbApi
                        .execute(dbOperation)
                        .then(function (key) {
                        resolve(key);
                    })
                        .catch(function (err) {
                        reject(_this.handleError(ContentError.restore_content_keys_failed, err));
                    });
                });
            })
                .catch(function (err) { return reject(_this.handleError(ContentError.fetch_content_failed, err)); });
        });
    };
    /**
     * Generate content key with key parts of each seeder to encrypt
     * content to be uploaded.
     * https://docs.decent.ch/developer/group___database_a_p_i___decent.html#ga4efd6c44e7257d496b79b102cd3d9358
     *
     * @param {string[]} seeders        Array of seeder account ids in format '1.2.X'. Example: ['1.2.12', '1.4.13']
     * @return {Promise<ContentKeys>}   Generated ContentKeys for content encryption.
     */
    ContentModule.prototype.generateContentKeys = function (seeders) {
        var _this = this;
        var dbOperation = new database_1.DatabaseOperations.GenerateContentKeys(seeders);
        return new Promise(function (resolve, reject) {
            _this.dbApi
                .execute(dbOperation)
                .then(function (keys) {
                resolve(keys);
            })
                .catch(function (err) {
                reject(_this.handleError(ContentError.database_operation_failed, err));
            });
        });
    };
    /**
     * Submit content to blockchain
     * https://docs.decent.ch/developer/group___wallet_a_p_i___content.html#gae0af8d611b5d915264a892ad83254370
     *
     * @param {SubmitObject} content    SubmitObject with information about submitted object.
     * @param {string} privateKey       Private for sign transaction in WIF(hex) (Wallet Import Format) format.
     * @param {boolean} broadcast
     * @return {Promise<boolean>}       Value confirming successful transaction broadcasting.
     */
    ContentModule.prototype.addContent = function (content, privateKey, broadcast) {
        var _this = this;
        if (broadcast === void 0) { broadcast = true; }
        return new Promise(function (resolve, reject) {
            content.size = _this.getFileSize(content.size);
            var listAssetOp = new database_1.DatabaseOperations.GetAssets([
                content.assetId || chain_1.ChainApi.asset_id,
                content.publishingFeeAsset || chain_1.ChainApi.asset_id
            ]);
            var methods = [new chain_2.ChainMethods.GetAccount(content.authorId)];
            methods.push.apply(methods, content.coAuthors.map(function (ca) { return new chain_2.ChainMethods.GetAccount(ca[0]); }));
            (_a = _this.chainApi).fetch.apply(_a, methods).then(function (accounts) {
                var authorAccount = JSON.parse(JSON.stringify(accounts[0]));
                var coAuthors = JSON.parse(JSON.stringify(accounts))
                    .slice(1)
                    .map(function (coAuthor, index) {
                    return [coAuthor.id, content.coAuthors[index][1]];
                });
                _this.dbApi.execute(listAssetOp)
                    .then(function (assets) {
                    if (!assets || !assets[0] || !assets[1]) {
                        reject(_this.handleError(ContentError.fetch_content_failed));
                        return;
                    }
                    var priceAsset = assets[0];
                    var feeAsset = assets[1];
                    try {
                        var submitOperation = new transaction_1.Operations.SubmitContentOperation(content.size, authorAccount.id, coAuthors, content.URI, content.seeders.length, [{
                                region: 1,
                                price: {
                                    amount: utils_1.Utils.formatAmountToAsset(content.price, priceAsset),
                                    asset_id: priceAsset.id
                                }
                            }], content.hash, content.seeders.map(function (s) { return s.seeder; }), content.keyParts, content.date.toString(), {
                            amount: _this.calculateFee(content),
                            asset_id: feeAsset.id
                        }, JSON.stringify(content.synopsis));
                        var transaction_2 = new transactionBuilder_1.TransactionBuilder();
                        var added = transaction_2.addOperation(submitOperation);
                        if (added === '') {
                            if (broadcast) {
                                transaction_2.broadcast(privateKey)
                                    .then(function () {
                                    resolve(transaction_2.operations[0]);
                                })
                                    .catch(function (err) {
                                    reject(_this.handleError(ContentError.transaction_broadcast_failed, err));
                                });
                            }
                            else {
                                resolve(transaction_2.operations[0]);
                            }
                        }
                        else {
                            reject(_this.handleError(ContentError.syntactic_error, added));
                            return;
                        }
                    }
                    catch (e) {
                        reject(_this.handleError(ContentError.account_fetch_failed, e));
                        return;
                    }
                })
                    .catch(function (err) { return _this.handleError(ContentError.database_operation_failed, err); });
            })
                .catch(function (err) { return reject(_this.handleError(ContentError.account_fetch_failed, err)); });
            var _a;
        });
    };
    /**
     * Get list of opened, not yet confirmed buy requests by seeders.
     * https://docs.decent.ch/developer/classgraphene_1_1app_1_1database__api__impl.html#ad4e75371b94ea3fd47cf4bd329b622aa
     *
     * @param {boolean} convertAsset            Optional parameter to convert amounts and fees of BuyingContent from blockchain asset
     *                                          amount format to right precision format of asset. Example: 100000000 => 1 DCT.
     *                                          Default: false.
     * @returns {Promise<BuyingContent[]>}      BuyingContent list of opened buy requests.
     */
    ContentModule.prototype.getOpenBuying = function (convertAsset) {
        var _this = this;
        if (convertAsset === void 0) { convertAsset = false; }
        return new Promise((function (resolve, reject) {
            var operation = new database_1.DatabaseOperations.GetOpenBuyings();
            _this.dbApi.execute(operation)
                .then(function (buyingObjects) {
                var listAssetsOp = new database_1.DatabaseOperations.ListAssets('', 100);
                _this.dbApi.execute(listAssetsOp)
                    .then(function (assets) {
                    if (!assets || assets.length === 0) {
                        reject(_this.handleError(ContentError.asset_fetch_failed));
                        return;
                    }
                    var result = convertAsset ? _this.formatPrices(buyingObjects, assets) : buyingObjects;
                    resolve(result);
                })
                    .catch(function (err) { return reject(_this.handleError(ContentError.database_operation_failed, err)); });
            })
                .catch(function (err) { return reject(_this.handleError(ContentError.database_operation_failed, err)); });
        }));
    };
    /**
     * Get list of opened, not yet confirmed buy requests by seeders.
     * https://docs.decent.ch/developer/classgraphene_1_1app_1_1database__api__impl.html#a030ccb8c903503a700ecbbc87bf552af
     *
     * @param {string} URI                  Buy request URI. Example 'ipfs:QmQ9MBkzt6QcDtBhg7qenDcXtm1s6VVSogtSHa2zbXKsFb'
     * @param {boolean} convertAsset        Optional parameter to convert amounts and fees of BuyingContent from blockchain asset
     *                                      amount format to right precision format of asset. Example: 100000000 => 1 DCT.
     *                                      Default: false.
     * @returns {Promise<BuyingContent[]>}  BuyingContent list of opened buy requests.
     */
    ContentModule.prototype.getOpenBuyingByURI = function (URI, convertAsset) {
        var _this = this;
        if (convertAsset === void 0) { convertAsset = false; }
        return new Promise((function (resolve, reject) {
            var operation = new database_1.DatabaseOperations.GetOpenBuyingsByURI(URI);
            _this.dbApi.execute(operation)
                .then(function (buyingObjects) {
                var listAssetsOp = new database_1.DatabaseOperations.ListAssets('', 100);
                _this.dbApi.execute(listAssetsOp)
                    .then(function (assets) {
                    if (!assets || assets.length === 0) {
                        reject(_this.handleError(ContentError.asset_fetch_failed));
                        return;
                    }
                    var result = convertAsset ? _this.formatPrices(buyingObjects, assets) : buyingObjects;
                    resolve(result);
                })
                    .catch(function (err) { return reject(_this.handleError(ContentError.database_operation_failed, err)); });
            })
                .catch(function (err) { return reject(_this.handleError(ContentError.database_operation_failed, err)); });
        }));
    };
    /**
     * Get list of opened, not yet confirmed buy requests by seeders.
     * https://docs.decent.ch/developer/classgraphene_1_1app_1_1database__api__impl.html#a767fc3bb252b35c33618f12083aa3064
     *
     * @param {string} accountId            Account id in format '1.2.X'. Example '1.2.345'
     * @param {boolean} convertAsset        Optional parameter to convert amounts and fees of BuyingContent from blockchain asset
     *                                      amount format to right precision format of asset. Example: 100000000 => 1 DCT.
     *                                      Default: false.
     * @returns {Promise<BuyingContent[]>}  BuyingContent list of opened buy requests.
     */
    ContentModule.prototype.getOpenBuyingByConsumer = function (accountId, convertAsset) {
        var _this = this;
        if (convertAsset === void 0) { convertAsset = false; }
        return new Promise((function (resolve, reject) {
            var operation = new database_1.DatabaseOperations.GetOpenBuyingsByConsumer(accountId);
            _this.dbApi.execute(operation)
                .then(function (buyingObjects) {
                var listAssetsOp = new database_1.DatabaseOperations.ListAssets('', 100);
                _this.dbApi.execute(listAssetsOp)
                    .then(function (assets) {
                    if (!assets || assets.length === 0) {
                        reject(_this.handleError(ContentError.asset_fetch_failed));
                        return;
                    }
                    var result = convertAsset ? _this.formatPrices(buyingObjects, assets) : buyingObjects;
                    resolve(result);
                })
                    .catch(function (err) { return reject(_this.handleError(ContentError.database_operation_failed, err)); });
            })
                .catch(function (err) { return reject(_this.handleError(ContentError.database_operation_failed, err)); });
        }));
    };
    /**
     * Get consumer's bought content identified by URI.
     * https://docs.decent.ch/developer/classgraphene_1_1app_1_1database__api__impl.html#a0b6a59e429592430cd91c6f8c82a5d6c
     *
     * @param {string} accountId                    Consumer's account id in format '1.2.X'. Example '1.2.345'
     * @param {string} URI                          Content URI. Example 'ipfs:QmQ9MBkzt6QcDtBhg7qenDcXtm1s6VVSogtSHa2zbXKsFb'
     * @param {boolean} convertAsset                Optional parameter to convert amounts and fees of BuyingContent from blockchain asset
     *                                              amount format to right precision format of asset. Example: 100000000 => 1 DCT.
     *                                              Default: false.
     * @returns {Promise<BuyingContent[] | null>}   List of bought content with URI.
     */
    ContentModule.prototype.getBuyingByConsumerURI = function (accountId, URI, convertAsset) {
        var _this = this;
        if (convertAsset === void 0) { convertAsset = false; }
        return new Promise((function (resolve, reject) {
            var operation = new database_1.DatabaseOperations.GetBuyingByConsumerURI(accountId, URI);
            _this.dbApi.execute(operation)
                .then(function (buyingObjects) {
                var listAssetsOp = new database_1.DatabaseOperations.ListAssets('', 100);
                _this.dbApi.execute(listAssetsOp)
                    .then(function (assets) {
                    if (!assets || assets.length === 0) {
                        reject(_this.handleError(ContentError.asset_fetch_failed));
                        return;
                    }
                    var result = convertAsset ? _this.formatPrices(buyingObjects, assets) : buyingObjects;
                    resolve(result);
                })
                    .catch(function (err) { return reject(_this.handleError(ContentError.database_operation_failed, err)); });
            })
                .catch(function (err) { return reject(_this.handleError(ContentError.database_operation_failed, err)); });
        }));
    };
    /**
     * Bought content history of account.
     * https://docs.decent.ch/developer/classgraphene_1_1app_1_1database__api__impl.html#a58b3b366a008ae2b0b7acd352da9969e
     *
     * @param {string} accountId            Account id in format '1.2.X'. Example '1.2.345'
     * @param {boolean} convertAsset        Optional parameter to convert amounts and fees of BuyingContent from blockchain asset
     *                                      amount format to right precision format of asset. Example: 100000000 => 1 DCT.
     *                                      Default: false.
     * @returns {Promise<BuyingContent[]>}  List of BuyingContent.
     */
    ContentModule.prototype.getBuyingHistoryObjectsByConsumer = function (accountId, convertAsset) {
        var _this = this;
        if (convertAsset === void 0) { convertAsset = false; }
        return new Promise(function (resolve, reject) {
            var getBuyingsHistoryObjectsByConsumerOp = new database_1.DatabaseOperations.GetBuyingsHistoryObjectsByConsumer(accountId);
            _this.dbApi.execute(getBuyingsHistoryObjectsByConsumerOp)
                .then(function (buyingObjects) {
                var listAssetsOp = new database_1.DatabaseOperations.ListAssets('', 100);
                _this.dbApi.execute(listAssetsOp)
                    .then(function (assets) {
                    if (!assets || assets.length === 0) {
                        reject(_this.handleError(ContentError.asset_fetch_failed));
                        return;
                    }
                    var result = convertAsset ? _this.formatPrices(buyingObjects, assets) : buyingObjects;
                    resolve(result);
                })
                    .catch(function (err) { return reject(_this.handleError(ContentError.database_operation_failed, err)); });
            })
                .catch(function (err) { return reject(_this.handleError(ContentError.database_operation_failed, err)); });
        });
    };
    /**
     * Format price Asset amounts to asset precision.
     *
     * @param {ContentExchangeObject[]} content     List of content to format.
     * @param {DCoreAssetObject[]} assets           Complete list of assets for formatting.
     * @returns {ContentExchangeObject[]}           List of content with formatted prices.
     */
    ContentModule.prototype.formatPrices = function (content, assets) {
        var result = content.map(function (obj) {
            var objCopy = Object.assign({}, obj);
            var assetsToFormat = [objCopy.price.hasOwnProperty('map_price')
                    ? objCopy.price.map_price[0][1]
                    : objCopy.price];
            if (objCopy.paid_price_before_exchange) {
                assetsToFormat.push(objCopy.paid_price_before_exchange);
            }
            if (objCopy.paid_price_after_exchange) {
                assetsToFormat.push(objCopy.paid_price_after_exchange);
            }
            assetsToFormat.forEach(function (priceAsset) {
                var asset = assets.find(function (a) { return a.id === priceAsset.asset_id; });
                priceAsset.amount = utils_1.Utils.formatAmountForAsset(priceAsset.amount, asset);
            });
            return objCopy;
        });
        return result;
    };
    /**
     * Calculate price of content submit for file size.
     *
     * @param fileSize  Size of file in bytes
     */
    ContentModule.prototype.getFileSize = function (fileSize) {
        return Math.ceil(fileSize / (1024 * 1024));
    };
    /**
     * Calculate submit price of content based on file size, expiration date and selected seeders.
     *
     * @param content SubmitObject for content to be uploaded
     */
    ContentModule.prototype.calculateFee = function (content) {
        var num_days = moment(content.date).diff(moment(), 'days') + 1;
        var fee = Math.ceil(this.getFileSize(content.size) *
            content.seeders.reduce(function (fee, seed) { return fee + seed.price.amount * num_days; }, 0));
        return fee;
    };
    /**
     * Request buy content.
     * https://docs.decent.ch/developer/group___wallet_a_p_i___content.html#ga5c57a25ade4da4c36466bd12f4b65401
     *
     * @param {string} contentId        Id of content to be bought in format '2.13.X'. Example: '2.13.456'
     * @param {string} buyerId          Account id of user buying content in format '1.2.X'. Example: '1.2.345'
     * @param {string} elGammalPub      ElGammal public key which will be used to identify users bought content
     * @param {string} privateKey       Private key to sign broadcasted transaction in WIF(hex) (Wallet Import Format) format.
     * @param {boolean} broadcast
     * @return {Promise<boolean>}       Value confirming successful transaction broadcasting.
     */
    ContentModule.prototype.buyContent = function (contentId, buyerId, elGammalPub, privateKey, broadcast) {
        var _this = this;
        if (broadcast === void 0) { broadcast = true; }
        return new Promise(function (resolve, reject) {
            _this.getContent(contentId)
                .then(function (content) {
                var buyOperation = new transaction_1.Operations.BuyContentOperation(content.URI, buyerId, content.price.map_price[0][1], 1, { s: elGammalPub });
                var transaction = new transactionBuilder_1.TransactionBuilder();
                var added = transaction.addOperation(buyOperation);
                if (added === '') {
                    if (broadcast) {
                        transaction.broadcast(privateKey)
                            .then(function () {
                            resolve(transaction.operations[0]);
                        })
                            .catch(function (err) {
                            reject(_this.handleError(ContentError.transaction_broadcast_failed, err));
                        });
                    }
                    else {
                        resolve(transaction.operations[0]);
                    }
                }
                else {
                    reject(_this.handleError(ContentError.syntactic_error, added));
                    return;
                }
            })
                .catch(function (err) {
                reject(_this.handleError(ContentError.fetch_content_failed, err));
            });
        });
    };
    /**
     * List available seeders ordered by price.
     * https://docs.decent.ch/developer/classgraphene_1_1app_1_1database__api__impl.html#a0fb24b59633fe48d8d4ff0bec4412f7b
     *
     * @param {number} resultSize       Number of results per request. Default 100(Max)
     * @return {Promise<Seeder[]>}      List of available Seeder objects.
     */
    ContentModule.prototype.getSeeders = function (resultSize) {
        var _this = this;
        if (resultSize === void 0) { resultSize = 100; }
        var dbOperation = new database_1.DatabaseOperations.ListSeeders(resultSize);
        return new Promise(function (resolve, reject) {
            _this.dbApi
                .execute(dbOperation)
                .then(function (result) {
                resolve(result);
            })
                .catch(function (err) {
                reject(_this.handleError(ContentError.database_operation_failed, err));
            });
        });
    };
    /**
     * Get list of not expired purchased content for account.
     * https://docs.decent.ch/developer/classgraphene_1_1app_1_1database__api__impl.html#a9b19baba864926274ef141c879b29e28
     *
     * @param {string} accountId        Account id in format '1.2.X'. Example: '1.2.345'
     * @param {string} order            Order of returned content list. Default is SearchParamsOrder.createdDesc
     * @param {string} startObjectId    Content object id from which list starts in format '2.13.X'. Example '2.13.234'. Default '0.0.0'
     * @param {string} term             Term to search in purchased content. Default ''
     * @param {number} resultSize       Number of results. Default 100(Max)
     * @return {Promise<Content[]>}     List of purchased content.
     */
    ContentModule.prototype.getPurchasedContent = function (accountId, order, startObjectId, term, resultSize) {
        var _this = this;
        if (order === void 0) { order = database_1.SearchParamsOrder.createdDesc; }
        if (startObjectId === void 0) { startObjectId = '0.0.0'; }
        if (term === void 0) { term = ''; }
        if (resultSize === void 0) { resultSize = 100; }
        return new Promise(function (resolve, reject) {
            if (!accountId) {
                reject('missing_parameter');
                return;
            }
            _this.searchContent({ count: resultSize })
                .then(function (allContent) {
                var dbOperation = new database_1.DatabaseOperations.GetBoughtObjectsByCustomer(accountId, order, startObjectId, term, resultSize);
                _this.dbApi
                    .execute(dbOperation)
                    .then(function (boughtContent) {
                    var result = [];
                    boughtContent.forEach(function (bought) {
                        allContent.forEach(function (content) {
                            if (bought.URI === content.URI) {
                                bought.synopsis = JSON.parse(bought.synopsis);
                                content.buy_id = bought.id;
                                result.push(content);
                            }
                        });
                    });
                    resolve(result);
                })
                    .catch(function (err) {
                    reject(_this.handleError(ContentError.database_operation_failed, err));
                });
            })
                .catch(function (err) {
                reject(_this.handleError(ContentError.fetch_content_failed, err));
            });
        });
    };
    /**
     * List rating for given content id.
     *
     * @param {string} contentId        Content if in format '2.13.X'. Example '2.13.456'
     * @param {string} forUser          Account id to search for user's ratings for conentnt, in format '1.2.X'. Example '1.2.345'.
     * @param {string} ratingStartId    Rating id to start list from.
     * @param {number} count
     * @return {Promise<Array<Rating>>}
     */
    ContentModule.prototype.getRating = function (contentId, forUser, ratingStartId, count) {
        var _this = this;
        if (ratingStartId === void 0) { ratingStartId = ''; }
        if (count === void 0) { count = 100; }
        return new Promise(function (resolve, reject) {
            _this.getContent(contentId)
                .then(function (res) {
                _this.searchFeedback(forUser, res.URI, ratingStartId, count)
                    .then(function (res) { return resolve(res); })
                    .catch(function (err) { return reject(_this.handleError(ContentError.database_operation_failed, err)); });
            })
                .catch(function (err) {
                reject(_this.handleError(ContentError.fetch_content_failed, err));
            });
        });
    };
    // TODO: need to discuss with Riso
    /**
     * https://docs.decent.ch/developer/classgraphene_1_1app_1_1database__api__impl.html#a624e679ac58b3edfc7b817e4a46e3746
     */
    ContentModule.prototype.searchFeedback = function (accountId, contentURI, ratingStartId, count) {
        var _this = this;
        if (count === void 0) { count = 100; }
        return new Promise(function (resolve, reject) {
            var operation = new database_1.DatabaseOperations.SearchFeedback(accountId, contentURI, ratingStartId, count);
            _this.dbApi.execute(operation)
                .then(function (res) {
                resolve(res);
            })
                .catch(function (err) {
                reject(_this.handleError(ContentError.database_operation_failed, err));
            });
        });
    };
    /**
     * Get author and co-authors of content.
     *
     * @param {string} URI   Content URI. Example 'ipfs:QmQ9MBkzt6QcDtBhg7qenDcXtm1s6VVSogtSHa2zbXKsFb'
     */
    ContentModule.prototype.getAuthorCoAuthors = function (URI) {
        var _this = this;
        return new Promise(function (resolve, reject) {
            var operation = new database_1.DatabaseOperations.GetContent(URI);
            _this.dbApi.execute(operation)
                .then(function (content) {
                if (!content) {
                    resolve(null);
                    return;
                }
                resolve([content.author, content.co_authors.map(function (ca) { return ca[0]; })]);
            })
                .catch(function (err) { return reject(_this.handleError(ContentError.database_operation_failed, err)); });
        });
    };
    /**
     * Send feedback for bought content with comment.
     * https://docs.decent.ch/developer/classgraphene_1_1wallet_1_1detail_1_1wallet__api__impl.html#a34d9dc81d177f87e5f501f182cf9212f
     *
     * @param {string} contentURI       Content URI. Example 'ipfs:QmQ9MBkzt6QcDtBhg7qenDcXtm1s6VVSogtSHa2zbXKsFb'
     * @param {string} consumer         Account id in format '1.2.X'. Example '1.2.345'
     * @param {string} comment          Comment for feedback.
     * @param {number} rating           Rating number from interval 1(Bad)-5(Good).
     * @param {string} consumerPKey     Account's private key to sign transaction in WIF(hex) (Wallet Import Format) format.
     * @returns {Promise<boolean>}      Value confirming successful transaction broadcasting.
     */
    ContentModule.prototype.leaveCommentAndRating = function (contentURI, consumer, comment, rating, consumerPKey) {
        var _this = this;
        return new Promise(function (resolve, reject) {
            var operation = new transaction_1.Operations.LeaveRatingAndComment(contentURI, consumer, comment, rating);
            var transaction = new transactionBuilder_1.TransactionBuilder();
            var added = transaction.addOperation(operation);
            if (added === '') {
                transaction.broadcast(consumerPKey)
                    .then(function () { return resolve(true); })
                    .catch(function (err) { return reject(_this.handleError(ContentError.transaction_broadcast_failed, err)); });
            }
            else {
                reject(_this.handleError(ContentError.syntactic_error, added));
                return;
            }
        });
    };
    return ContentModule;
}(ApiModule_1.ApiModule));
exports.ContentModule = ContentModule;
//# sourceMappingURL=content.js.map