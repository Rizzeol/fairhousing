"use strict";
var __extends = (this && this.__extends) || (function () {
    var extendStatics = Object.setPrototypeOf ||
        ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||
        function (d, b) { for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p]; };
    return function (d, b) {
        extendStatics(d, b);
        function __() { this.constructor = d; }
        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
    };
})();
Object.defineProperty(exports, "__esModule", { value: true });
var database_1 = require("../api/model/database");
var crypt_1 = require("../crypt");
var transaction_1 = require("../model/transaction");
var transactionBuilder_1 = require("../transactionBuilder");
var utils_1 = require("../utils");
var chain_1 = require("../api/chain");
var ApiModule_1 = require("./ApiModule");
var chain_2 = require("../api/model/chain");
var asset_1 = require("../model/asset");
var AssetModule = /** @class */ (function (_super) {
    __extends(AssetModule, _super);
    function AssetModule(dbApi, apiConnector, chainApi) {
        var _this = _super.call(this, {
            apiConnector: apiConnector,
            dbApi: dbApi,
            chainApi: chainApi
        }) || this;
        _this.MAX_SHARED_SUPPLY = 7319777577456890;
        return _this;
    }
    /**
     *  List assets available on DCore network.
     *  https://docs.decent.ch/developer/classgraphene_1_1app_1_1database__api__impl.html#adaff907a467869849e77c3ac0b8beca8
     *
     * @param {string} lowerBoundSymbol     Asset symbol to start list with. Example 'DCT'
     * @param {number} limit                Number of results. Default 100(Max)
     * @param {boolean} formatAssets        Optional parameter to convert amounts and fees of AssetObject from blockchain asset
     *                                      amount format to right precision format of asset. Example: 100000000 => 1 DCT.
     *                                      Default: false.
     * @returns {AssetObject[]}             AssetObject list.
     */
    AssetModule.prototype.listAssets = function (lowerBoundSymbol, limit, formatAssets) {
        var _this = this;
        if (limit === void 0) { limit = 100; }
        if (formatAssets === void 0) { formatAssets = false; }
        return new Promise(function (resolve, reject) {
            var operation = new database_1.DatabaseOperations.ListAssets(lowerBoundSymbol, limit);
            _this.dbApi.execute(operation)
                .then(function (assets) {
                resolve(formatAssets ? _this.formatAssets(assets) : assets);
            })
                .catch(function (err) {
                reject(_this.handleError(asset_1.AssetError.unable_to_list_assets, err));
            });
        });
    };
    /**
     * Create UIA(User Issued Asset).
     * https://docs.decent.ch/developer/classgraphene_1_1wallet_1_1detail_1_1wallet__api__impl.html#a3f5461005ce7d6fb69a8878a6513fe1f
     *
     * @param {string} issuer                   Issuer's account id in format '1.2.X'. Example '1.2.345'.
     * @param {string} symbol                   Symbol of newly created asset. NOTE: Price for create asset is based on number of letters.
     *                                          used in asset symbol.
     * @param {number} precision                Number of fraction digits for asset.
     * @param {string} description              Asset description. Maximum length is 1000 chars.
     * @param {number} maxSupply                The maximum supply of this asset which may exist at any given time
     * @param {number} baseExchangeAmount       Amount of custom tokens for exchange rate to quoteExchangeAmount DCT tokens.
     * @param {number} quoteExchangeAmount      Number of DCT tokens for rxchange rate.
     * @param {boolean} isExchangable           Set 'true' to allow implicit conversion of asst to core asset.
     * @param {boolean} isSupplyFixed           Set value 'true' to fixate token maxSupply, 'false' for changeable maxSupply value.
     *                                          NOTE: only can be changed from 'false' to 'true'
     * @param {string} issuerPrivateKey         Private key to sign transaction in WIF(hex) (Wallet Import Format) format.
     * @returns {Promise<boolean>}              Value confirming successful transaction broadcasting.
     */
    AssetModule.prototype.createUserIssuedAsset = function (issuer, symbol, precision, description, maxSupply, baseExchangeAmount, quoteExchangeAmount, isExchangeable, isSupplyFixed, issuerPrivateKey) {
        var _this = this;
        var options = {
            max_supply: maxSupply,
            core_exchange_rate: {
                base: {
                    amount: baseExchangeAmount,
                    asset_id: '1.3.0'
                },
                quote: {
                    amount: quoteExchangeAmount,
                    asset_id: '1.3.1'
                }
            },
            is_exchangeable: isExchangeable,
            extensions: [[
                    1, {
                        'is_fixed_max_supply': isSupplyFixed
                    }
                ]]
        };
        var operation = new transaction_1.Operations.AssetCreateOperation(issuer, symbol, precision, description, options);
        return new Promise(function (resolve, reject) {
            _this.apiConnector.connect()
                .then(function () {
                var transaction = new transactionBuilder_1.TransactionBuilder();
                var added = transaction.addOperation(operation);
                if (added === '') {
                    transaction.broadcast(issuerPrivateKey)
                        .then(function () { return resolve(true); })
                        .catch(function (err) { return reject(_this.handleError(asset_1.AssetError.transaction_broadcast_failed, err)); });
                }
                else {
                    reject(_this.handleError(asset_1.AssetError.syntactic_error, added));
                    return;
                }
            })
                .catch(function (err) {
                reject(_this.handleError(asset_1.AssetError.connection_failed, err));
                return;
            });
        });
    };
    /**
     * Issue created custom user token to account.
     * https://docs.decent.ch/developer/classgraphene_1_1wallet_1_1detail_1_1wallet__api__impl.html#a995074673211a3a6c4d94cafefd0ad56
     *
     * @param {string} assetSymbol          Asset symbol of asset to be issued. Example 'DCT'
     * @param {number} amount               Amount of asset ot be issued
     * @param {string} issueToAccount       Account id to whom asset will be issued. In format '1.2.X'. Example '1.2.345.
     * @param {string} memo                 Message for asset receiver
     * @param {string} issuerPKey           Issuer private key for transaction sign
     * @returns {Promise<boolean>}          Value confirming successful transaction broadcasting.
     */
    AssetModule.prototype.issueAsset = function (assetSymbol, amount, issueToAccount, memo, issuerPKey) {
        var _this = this;
        return new Promise(function (resolve, reject) {
            _this.listAssets(assetSymbol, 1)
                .then(function (assets) {
                if (assets.length === 0 || !assets[0]) {
                    reject('asset_not_found');
                    return;
                }
                var asset = assets[0];
                var issuer = asset.issuer;
                var operations = [].concat(new chain_2.ChainMethods.GetAccount(issueToAccount), new chain_2.ChainMethods.GetAccount(issuer));
                (_a = _this.chainApi).fetch.apply(_a, operations).then(function (res) {
                    var issueToAcc = res[0], issuerAcc = res[1];
                    var privateKeyIssuer = utils_1.Utils.privateKeyFromWif(issuerPKey);
                    var pubKeyIssuer = utils_1.Utils.publicKeyFromString(issuerAcc.get('options').get('memo_key'));
                    var pubKeyIssueTo = utils_1.Utils.publicKeyFromString(issueToAcc.get('options').get('memo_key'));
                    var memoObject = undefined;
                    if (memo) {
                        memoObject = {
                            from: pubKeyIssuer.stringKey,
                            to: pubKeyIssueTo.stringKey,
                            nonce: utils_1.Utils.generateNonce(),
                            message: crypt_1.CryptoUtils.encryptWithChecksum(memo, privateKeyIssuer, pubKeyIssueTo, utils_1.Utils.generateNonce())
                        };
                    }
                    var operation = new transaction_1.Operations.IssueAssetOperation(issuer, {
                        asset_id: asset.id,
                        amount: amount
                    }, issueToAccount, memoObject);
                    var transaction = new transactionBuilder_1.TransactionBuilder();
                    var added = transaction.addOperation(operation);
                    if (added === '') {
                        transaction.broadcast(issuerPKey)
                            .then(function (res) { return resolve(true); })
                            .catch(function (err) {
                            reject(_this.handleError(asset_1.AssetError.asset_issue_failure, err));
                        });
                    }
                    else {
                        reject(_this.handleError(asset_1.AssetError.syntactic_error, added));
                    }
                })
                    .catch(function (err) {
                    reject(_this.handleError(asset_1.AssetError.failed_to_fetch_account, err));
                });
                var _a;
            })
                .catch(function (err) { return reject(_this.handleError(asset_1.AssetError.unable_to_list_assets, err)); });
        });
    };
    /**
     * Update information in custom token.
     * https://docs.decent.ch/developer/classgraphene_1_1wallet_1_1detail_1_1wallet__api__impl.html#af5248d111fa885580636adb468d92e16
     *
     * @param {string} symbol                   Asset symbol of updated asset. Example 'DCT'.
     * @param {UserIssuedAssetInfo} newInfo     New information for update.
     * @param {string} issuerPKey               Account private key for transaction sign.
     * @returns {Promise<any>}                  Value confirming successful transaction broadcasting.
     */
    AssetModule.prototype.updateUserIssuedAsset = function (symbol, newInfo, issuerPKey) {
        var _this = this;
        return new Promise(function (resolve, reject) {
            _this.listAssets(symbol, 1)
                .then(function (assets) {
                if (assets.length === 0 || !assets[0]) {
                    reject(_this.handleError(asset_1.AssetError.asset_not_found));
                    return;
                }
                var asset = assets[0];
                var maxSupply = Number(asset.options.max_supply);
                if (newInfo.maxSupply !== undefined) {
                    maxSupply = newInfo.maxSupply;
                }
                var isExchangable = asset.options.is_exchangeable;
                if (newInfo.isExchangable !== undefined) {
                    isExchangable = newInfo.isExchangable;
                }
                var operation = new transaction_1.Operations.UpdateAssetIssuedOperation(asset.issuer, asset.id, newInfo.description || asset.description, maxSupply, newInfo.coreExchange || asset.options.core_exchange_rate, isExchangable, newInfo.newIssuer);
                var transaction = new transactionBuilder_1.TransactionBuilder();
                var added = transaction.addOperation(operation);
                if (added === '') {
                    transaction.broadcast(issuerPKey)
                        .then(function (res) { return resolve(true); })
                        .catch(function (err) { return reject(_this.handleError(asset_1.AssetError.transaction_broadcast_failed, err)); });
                }
                else {
                    reject(_this.handleError(asset_1.AssetError.syntactic_error, added));
                    return;
                }
            })
                .catch(function (err) { return reject(_this.handleError(asset_1.AssetError.unable_to_list_assets, err)); });
        });
    };
    /**
     * Fund asset pools for asset exchanging.
     * https://docs.decent.ch/developer/classgraphene_1_1wallet_1_1detail_1_1wallet__api__impl.html#ab018196310aaa6118877d219d9749305
     *
     * @param {string} fromAccountId     Account id of account sending DCT asset. In format '1.2.X'. Example '1.2.345'.s
     * @param {number} uiaAmount         Amount of custom token to be send to pool.
     * @param {string} uiaSymbol         Asset symbol of custom token which pool to be funded.
     * @param {number} dctAmount         Amount of DCT token to be send to pool.
     * @param {string} dctSymbol         Asset symbol of DCT asset. Set always to 'DCT'.
     * @param {string} privateKey        Account private key used for signing transaction.
     * @returns {Promise<boolean>}       Value confirming successful transaction broadcasting.
     */
    AssetModule.prototype.fundAssetPools = function (fromAccountId, uiaAmount, uiaSymbol, dctAmount, privateKey) {
        var _this = this;
        return new Promise(function (resolve, reject) {
            var dctSymbol = chain_1.ChainApi.asset_id;
            Promise.all([
                _this.listAssets(uiaSymbol, 1),
                _this.listAssets(dctSymbol, 1)
            ])
                .then(function (res) {
                var uia = res[0], dct = res[1];
                if (uia.length === 0 || dct.length === 0 || !uia[0] || !dct[0]) {
                    reject(_this.handleError(asset_1.AssetError.asset_not_found));
                    return;
                }
                var operation = new transaction_1.Operations.AssetFundPools(fromAccountId, {
                    asset_id: uia[0].id,
                    amount: uiaAmount
                }, {
                    asset_id: dct[0].id,
                    amount: dctAmount
                });
                var transaction = new transactionBuilder_1.TransactionBuilder();
                var added = transaction.addOperation(operation);
                if (added === '') {
                    transaction.broadcast(privateKey)
                        .then(function () { return resolve(true); })
                        .catch(function (err) { return reject(_this.handleError(asset_1.AssetError.transaction_broadcast_failed, err)); });
                }
                else {
                    reject(_this.handleError(asset_1.AssetError.syntactic_error, added));
                    return;
                }
            })
                .catch(function (err) { return reject(_this.handleError(asset_1.AssetError.unable_to_list_assets, err)); });
        });
    };
    /**
     * Discard asset from network circulation.
     * https://docs.decent.ch/developer/classgraphene_1_1wallet_1_1detail_1_1wallet__api__impl.html#ae79e94dc01997493539ab0e01a505c03
     *
     * @param {string} payer            Account id in format '1.2.X'. Example '1.2.345'.
     * @param {string} symbol           Asset symbol of asset to be removed.
     * @param {number} amountToReserve  Amount of asset to be removed.
     * @param {string} privateKey       Payer's private key to sign the transaction.
     * @returns {Promise<boolean>}      Value confirming successful transaction broadcasting.
     */
    AssetModule.prototype.assetReserve = function (payer, symbol, amountToReserve, privateKey) {
        var _this = this;
        return new Promise(function (resolve, reject) {
            _this.listAssets(symbol, 1)
                .then(function (res) {
                if (res.length !== 1 || !res[0]) {
                    reject(_this.handleError(asset_1.AssetError.asset_not_found));
                    return;
                }
                var dynamicObject = new database_1.DatabaseOperations.GetObjects([res[0].dynamic_asset_data_id]);
                _this.dbApi.execute(dynamicObject)
                    .then(function (result) {
                    if (result[0].current_supply === 0) {
                        reject(_this.handleError('Current supply of dynamic asset data is 0, must be greater than 0'));
                        return;
                    }
                    var operation = new transaction_1.Operations.AssetReserve(payer, {
                        asset_id: res[0].id,
                        amount: amountToReserve
                    });
                    var transaction = new transactionBuilder_1.TransactionBuilder();
                    var added = transaction.addOperation(operation);
                    if (added === '') {
                        transaction.broadcast(privateKey)
                            .then(function () { return resolve(true); })
                            .catch(function (err) { return reject(_this.handleError(asset_1.AssetError.transaction_broadcast_failed, err)); });
                    }
                    else {
                        reject(_this.handleError(asset_1.AssetError.syntactic_error, added));
                        return;
                    }
                })
                    .catch();
            })
                .catch(function (err) { return reject(_this.handleError(asset_1.AssetError.unable_to_list_assets, err)); });
        });
    };
    /**
     * Withdraw from asset pools.
     * https://docs.decent.ch/developer/classgraphene_1_1wallet_1_1detail_1_1wallet__api__impl.html#ac812b96ccef7f81ca97ebda433d98e63
     *
     * @param {string} issuer       Issuer's account id in format '1.2.X'. Example '1.2.345'.
     * @param {string} uiaAmount    Custom asset amount.
     * @param {string} uiaSymbol    Custom asset symbol.
     * @param {string} dctAmount    Amount of core DCT asset.
     * @param {string} dctSymbol    DCT asset symbol. Always set to 'DCT'.
     * @param {string} privateKey   Issuer's private key to sign the transaction.
     * @returns {Promise<boolean>}  Value confirming successful transaction broadcasting.
     */
    AssetModule.prototype.assetClaimFees = function (issuer, uiaAmount, uiaSymbol, dctAmount, privateKey) {
        var _this = this;
        return new Promise(function (resolve, reject) {
            var dctSymbol = chain_1.ChainApi.asset_id;
            Promise.all([
                _this.listAssets(uiaSymbol, 1),
                _this.listAssets(dctSymbol, 1)
            ])
                .then(function (res) {
                var uia = res[0], dct = res[1];
                if (uia.length === 0 || dct.length === 0 || !uia[0] || !dct[0]) {
                    reject(_this.handleError(asset_1.AssetError.asset_not_found));
                    return;
                }
                var uiaAsset = {
                    asset_id: uia[0].id,
                    amount: uiaAmount
                };
                var dctAsset = {
                    asset_id: dct[0].id,
                    amount: dctAmount
                };
                var operation = new transaction_1.Operations.AssetClaimFeesOperation(issuer, uiaAsset, dctAsset);
                var transaction = new transactionBuilder_1.TransactionBuilder();
                var added = transaction.addOperation(operation);
                if (added === '') {
                    transaction.broadcast(privateKey)
                        .then(function () { return resolve(true); })
                        .catch(function (err) { return reject('failed_to_broadcast_transaction'); });
                }
                else {
                    reject(_this.handleError(asset_1.AssetError.syntactic_error, added));
                }
            })
                .catch(function (err) {
                reject('failed_load_assets');
            });
        });
    };
    /**
     * Get asset object.
     * https://docs.decent.ch/developer/classgraphene_1_1wallet_1_1detail_1_1wallet__api__impl.html#a012e918ecef1d24b2dee7ef64dca5018
     *
     * @param {string} assetId                  Asset id in format '1.3.X'. Example '1.3.0'.
     * @param {string} formatAsset              Optional parameter to convert amounts and fees of DCoreAssetObject from blockchain asset
     *                                          amount format to right precision format of asset. Example: 100000000 => 1 DCT.
     *                                          Default: false.
     * @returns {Promise<DCoreAssetObject>}     DCoreAssetObject of desired asset.
     */
    AssetModule.prototype.getAsset = function (assetId, formatAsset) {
        var _this = this;
        if (formatAsset === void 0) { formatAsset = false; }
        var operation = new database_1.DatabaseOperations.GetAssets([assetId]);
        return new Promise(function (resolve, reject) {
            _this.dbApi.execute(operation)
                .then(function (assets) {
                if (!assets || !assets[0]) {
                    reject(_this.handleError(asset_1.AssetError.asset_not_found));
                    return;
                }
                resolve(formatAsset ? _this.formatAssets(assets)[0] : assets[0]);
            })
                .catch(function (err) { return reject(err); });
        });
    };
    /**
     * List of desired assets.
     * https://docs.decent.ch/developer/classgraphene_1_1app_1_1database__api__impl.html#ad88d6aec5d661d7f7c40a83291d78ea8
     *
     * @param {string[]} assetIds               List of asset ids to get. Example ['1.3.0', '1.3.1']
     * @param {boolean} formatAssets            Optional parameter to convert amounts and fees of DCoreAssetObject from blockchain asset
     *                                          amount format to right precision format of asset. Example: 100000000 => 1 DCT.
     *                                          Default: false.
     * @returns {Promise<DCoreAssetObject>}     DCoreAssetObject of desired asset.
     */
    AssetModule.prototype.getAssets = function (assetIds, formatAssets) {
        var _this = this;
        if (formatAssets === void 0) { formatAssets = false; }
        var operation = new database_1.DatabaseOperations.GetAssets(assetIds);
        return new Promise(function (resolve, reject) {
            _this.dbApi.execute(operation)
                .then(function (res) { return resolve(formatAssets ? _this.formatAssets(res) : res); })
                .catch(function (err) { return reject(err); });
        });
    };
    /**
     * Format asset to DCore DCT asset format
     *
     * @deprecated                  This method will be removed in future versions
     * @param {string} symbol       Asset symbol
     * @param {string} amount       Amount to format
     * @returns  {Promise<Asset>}   Formatted Asset object
     */
    AssetModule.prototype.priceToDCT = function (symbol, amount) {
        var _this = this;
        return new Promise(function (resolve, reject) {
            _this.listAssets(symbol, 1)
                .then(function (assets) {
                if (assets.length !== 1 || !assets[0]) {
                    reject(_this.handleError(asset_1.AssetError.asset_not_found));
                    return;
                }
                var asset = assets[0];
                var operation = new database_1.DatabaseOperations.PriceToDCT({
                    asset_id: asset.id,
                    amount: utils_1.Utils.formatAmountToAsset(amount, asset)
                });
                _this.dbApi.execute(operation)
                    .then(function (res) { return resolve(res); })
                    .catch(function (err) { return reject(_this.handleError(asset_1.AssetError.database_operation_failed, err)); });
            })
                .catch(function (err) { return reject(_this.handleError(asset_1.AssetError.unable_to_list_assets, err)); });
        });
    };
    /**
     * Miner proposes exchange rate for monitored asset.
     * NOTE: Only active miners can.
     * https://docs.decent.ch/developer/group___wallet_a_p_i___asset.html#ga4ae6711f7d7ab2912d3e3b0a2997a8c3
     *
     * @param {string} publishingAccount
     * @param {string} symbol
     * @param {number} exchangeBaseAmount
     * @param {string} exchangeQuoteAmount
     * @param {string} privateKey
     * @returns {Promise<boolean>}  Value confirming successful transaction broadcasting.
     */
    AssetModule.prototype.publishAssetFeed = function (publishingAccount, symbol, exchangeBaseAmount, exchangeQuoteAmount, privateKey) {
        var _this = this;
        return new Promise(function (resolve, reject) {
            _this.listAssets(symbol, 1)
                .then(function (assets) {
                if (assets.length !== 1 || !assets[0]) {
                    reject('asset_not_found');
                    return;
                }
                var asset = assets[0];
                var feed = {
                    core_exchange_rate: {
                        quote: {
                            amount: exchangeQuoteAmount,
                            asset_id: '1.3.0'
                        },
                        base: {
                            asset_id: asset.id,
                            amount: exchangeBaseAmount
                        }
                    }
                };
                var operation = new transaction_1.Operations.AssetPublishFeed(publishingAccount, asset.id, feed);
                var transaction = new transactionBuilder_1.TransactionBuilder();
                var added = transaction.addOperation(operation);
                if (added === '') {
                    transaction.broadcast(privateKey)
                        .then(function () { return resolve(true); })
                        .catch(function (err) { return reject(_this.handleError(asset_1.AssetError.transaction_broadcast_failed, err)); });
                }
                else {
                    reject(_this.handleError(asset_1.AssetError.syntactic_error, added));
                    return;
                }
            })
                .catch(function (err) {
                reject(_this.handleError(asset_1.AssetError.unable_to_list_assets, err));
            });
        });
    };
    /**
     * List miner's proposed feeds.
     * https://docs.decent.ch/developer/classgraphene_1_1app_1_1database__api__impl.html#a56a36fac11722644d2bdfd9552b13658
     *
     * @param {string} minerAccountId
     * @param {number} limit
     * @returns {Promise<any>}
     */
    AssetModule.prototype.getFeedsByMiner = function (minerAccountId, limit) {
        var _this = this;
        if (limit === void 0) { limit = 100; }
        return new Promise(function (resolve, reject) {
            var operation = new database_1.DatabaseOperations.GetFeedsByMiner(minerAccountId, limit);
            _this.dbApi.execute(operation)
                .then(function (res) { return resolve(res); })
                .catch(function (err) { return reject(_this.handleError(asset_1.AssetError.database_operation_failed, err)); });
        });
    };
    /**
     * Amount of active DCT tokens in DCore network circulation.
     * @returns {Promise<any>}
     */
    AssetModule.prototype.getRealSupply = function () {
        var _this = this;
        return new Promise(function (resolve, reject) {
            var operation = new database_1.DatabaseOperations.GetRealSupply();
            _this.dbApi.execute(operation)
                .then(function (res) { return resolve(res); })
                .catch(function (err) { return reject(_this.handleError(asset_1.AssetError.database_operation_failed, err)); });
        });
    };
    /**
     * Get monitored asset options of selected asset.
     * https://docs.decent.ch/developer/group___wallet_a_p_i___asset.html#ga10bc8c39c64b7fe31c0f27613162ea16
     *
     * @param {string} assetId                          Monitored asset id in format '1.3.X'. Example '1.3.45'.
     * @returns {Promise<MonitoredAssetOptions|null>}   MonitoredAssetOptions object or null if asset is not monitored
     */
    AssetModule.prototype.getMonitoredAssetData = function (assetId) {
        var _this = this;
        var operation = new database_1.DatabaseOperations.GetAssets([assetId]);
        return new Promise(function (resolve, reject) {
            _this.dbApi.execute(operation)
                .then(function (res) {
                if (res.length === 0) {
                    resolve(null);
                    return;
                }
                if (!('monitored_asset_opts' in res[0])) {
                    resolve(null);
                    return;
                }
                resolve(res[0].monitored_asset_opts);
            })
                .catch(function (err) { return reject(_this.handleError(asset_1.AssetError.unable_to_list_assets, err)); });
        });
    };
    AssetModule.prototype.formatAssets = function (assets) {
        var res = assets.map(function (asset) {
            var a = Object.assign({}, asset);
            a.options.core_exchange_rate.base.amount = asset.options.core_exchange_rate.base.amount / chain_1.ChainApi.DCTPower;
            a.options.core_exchange_rate.quote.amount = utils_1.Utils.formatAmountForAsset(asset.options.core_exchange_rate.quote.amount, asset);
            if (asset.monitored_asset_opts) {
                a.monitored_asset_opts.current_feed.core_exchange_rate.base.amount =
                    asset.options.core_exchange_rate.base.amount / chain_1.ChainApi.DCTPower;
                a.monitored_asset_opts.current_feed.core_exchange_rate.quote.amount = utils_1.Utils.formatAmountForAsset(asset.options.core_exchange_rate.quote.amount, asset);
            }
            return a;
        });
        return res;
    };
    /**
     * Create monitored asset.
     * NOTE: only miner can create monitored asset.
     * https://docs.decent.ch/developer/classgraphene_1_1wallet_1_1detail_1_1wallet__api__impl.html#a03534abbae12c7aa01ca5afb4ceb9575
     *
     * @param {string} issuer               Account id of miner who creating monitored asset. In format '1.2.X'. Example '1.2.345'.
     * @param {string} symbol               Asset symbol of newly created asset. Example 'MONAST'.
     * @param {number} precision            Number of digits on the right side of decimal point. Value needs to be lower-equal 12.
     * @param {string} description          Assets's description. Up to 1000 characters.
     * @param {number} feedLifetimeSec      Time during which is active miners feed proposals valid.
     * @param {number} minimumFeeds         Minimum number of feed proposals from miners.
     * @param {string} issuerPrivateKey     Issuer's private key to sign the transaction.
     * @returns {Promise<boolean>}          Value confirming successful transaction broadcasting.
     */
    AssetModule.prototype.createMonitoredAsset = function (issuer, symbol, precision, description, feedLifetimeSec, minimumFeeds, issuerPrivateKey) {
        var _this = this;
        return new Promise(function (resolve, reject) {
            var coreExchangeRate = {
                base: {
                    amount: 0,
                    asset_id: '1.3.0'
                },
                quote: {
                    amount: 0,
                    asset_id: '1.3.0'
                }
            };
            var options = {
                max_supply: 0,
                core_exchange_rate: coreExchangeRate,
                is_exchangeable: true,
                extensions: []
            };
            var monitoredOptions = {
                feeds: [],
                current_feed: {
                    core_exchange_rate: coreExchangeRate,
                },
                current_feed_publication_time: _this.convertDateToSeconds(),
                feed_lifetime_sec: feedLifetimeSec,
                minimum_feeds: minimumFeeds
            };
            var operation = new transaction_1.Operations.AssetCreateOperation(issuer, symbol, precision, description, options, monitoredOptions);
            var getGlobalPropertiesOperation = new database_1.DatabaseOperations.GetGlobalProperties();
            _this.dbApi.execute(getGlobalPropertiesOperation)
                .then(function (result) {
                var proposalCreateParameters1 = {
                    fee_paying_account: issuer,
                    expiration_time: _this.getDate(_this.convertSecondsToDays(result.parameters.miner_proposal_review_period) + 2),
                    review_period_seconds: result.parameters.miner_proposal_review_period,
                    extensions: []
                };
                var proposalCreateParameters2 = {
                    fee_paying_account: issuer,
                    expiration_time: _this.getDate(_this.convertSecondsToDays(result.parameters.miner_proposal_review_period) + 1),
                    review_period_seconds: result.parameters.miner_proposal_review_period,
                    extensions: []
                };
                var transaction = new transactionBuilder_1.TransactionBuilder();
                var added = transaction.addOperation(operation);
                if (added === '') {
                    transaction.propose(proposalCreateParameters2);
                    transaction.propose(proposalCreateParameters1);
                    transaction.broadcast(issuerPrivateKey)
                        .then(function (result) {
                        resolve(true);
                    })
                        .catch(function (error) {
                        reject(_this.handleError(asset_1.AssetError.transaction_broadcast_failed, error));
                        return;
                    });
                }
                else {
                    reject(_this.handleError(asset_1.AssetError.syntactic_error, added));
                    return;
                }
            })
                .catch(function (error) {
                reject(_this.handleError(asset_1.AssetError.database_operation_failed, error));
                return;
            });
        });
    };
    /**
     * Update information in monitored asset.
     * https://docs.decent.ch/developer/classgraphene_1_1wallet_1_1detail_1_1wallet__api__impl.html#adfa5687dce7e6cb119dd14151006e8bf
     *
     * @param {string} symbol               Asset symbol to be updated.
     * @param {string} description          New description for monitored asset. Up to 1000 characters.
     * @param {number} feedLifetimeSec      Time during which is active miners feed proposals valid.
     * @param {number} minimumFeeds         Minimum number of feed proposals from miners.
     * @param {string} privateKey           Issuer's private key to sign the transaction.
     * @returns {Promise<boolean>}          Value confirming successful transaction broadcasting.
     */
    AssetModule.prototype.updateMonitoredAsset = function (symbol, description, feedLifetimeSec, minimumFeeds, privateKey) {
        var _this = this;
        return new Promise(function (resolve, reject) {
            _this.listAssets(symbol, 1)
                .then(function (assets) {
                if (assets.length === 0 || !assets[0] || assets[0].symbol !== symbol) {
                    reject(_this.handleError(asset_1.AssetError.asset_not_found));
                    return;
                }
                var asset = assets[0];
                var parameters = {
                    issuer: asset.issuer,
                    asset_to_update: asset.id,
                    new_description: description,
                    new_feed_lifetime_sec: feedLifetimeSec,
                    new_minimum_feeds: minimumFeeds,
                };
                var operation = new transaction_1.Operations.UpdateMonitoredAssetOperation(parameters);
                var transaction = new transactionBuilder_1.TransactionBuilder();
                var added = transaction.addOperation(operation);
                if (added === '') {
                    transaction.broadcast(privateKey)
                        .then(function () {
                        resolve(true);
                    })
                        .catch(function (error) {
                        reject(_this.handleError(asset_1.AssetError.transaction_broadcast_failed, error));
                        return;
                    });
                }
                else {
                    reject(_this.handleError(asset_1.AssetError.syntactic_error, added));
                    return;
                }
            })
                .catch(function (error) {
                reject(_this.handleError(asset_1.AssetError.database_operation_failed, error));
                return;
            });
        });
    };
    AssetModule.prototype.convertDateToSeconds = function () {
        return new Date().getTime() / 1000 | 0;
    };
    AssetModule.prototype.convertSecondsToDays = function (seconds) {
        return seconds / 24 / 60 / 60;
    };
    AssetModule.prototype.getDate = function (days) {
        if (days === void 0) { days = 0; }
        var date = new Date();
        var newDate = new Date();
        newDate.setDate(date.getDate() + days);
        newDate.setUTCHours(0, 0, 0);
        return newDate.toISOString().split('.')[0];
    };
    return AssetModule;
}(ApiModule_1.ApiModule));
exports.AssetModule = AssetModule;
//# sourceMappingURL=asset.js.map