"use strict";
var __extends = (this && this.__extends) || (function () {
    var extendStatics = Object.setPrototypeOf ||
        ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||
        function (d, b) { for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p]; };
    return function (d, b) {
        extendStatics(d, b);
        function __() { this.constructor = d; }
        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
    };
})();
Object.defineProperty(exports, "__esModule", { value: true });
var database_1 = require("../api/model/database");
var transaction_1 = require("../model/transaction");
var account_1 = require("../model/account");
var transactionBuilder_1 = require("../transactionBuilder");
var ApiModule_1 = require("./ApiModule");
var mining_1 = require("../model/mining");
var chain_1 = require("../api/model/chain");
var MiningModule = /** @class */ (function (_super) {
    __extends(MiningModule, _super);
    function MiningModule(dbApi, apiConnector, chainApi) {
        return _super.call(this, {
            dbApi: dbApi,
            apiConnector: apiConnector,
            chainApi: chainApi
        }) || this;
    }
    MiningModule.getSortedMiners = function (minersVoteIds) {
        var res = [].concat.apply([], minersVoteIds);
        res.sort(function (e1, e2) {
            return Number(e1.split(':')[1]) - Number(e2.split(':')[1]);
        });
        return res;
    };
    MiningModule.removeVotedMiners = function (voted, toUnvote) {
        var res = [].concat.apply([], voted);
        toUnvote.forEach(function (u) {
            var index = res.indexOf(u);
            if (index > 0) {
                res.splice(index, 1);
            }
        });
        return res;
    };
    MiningModule.createVoteIdList = function (ids, objects) {
        var res = [];
        ids.forEach(function (m) {
            var miner = objects.find(function (el) { return el.id === m; });
            res.push(miner.vote_id);
        });
        return res;
    };
    /**
     * Place vote for change of number of active miners.
     * https://docs.decent.ch/developer/classgraphene_1_1wallet_1_1detail_1_1wallet__api__impl.html#aeffdd3eb57a9f4877d660ca4ccd7d9f5
     *
     * @param {string} accountId            Id of account which placing vote, in format '1.2.X'. Example '1.2.345'.
     * @param {number} desiredNumOfMiners   Desired number of active miners in DCore network.
     * @param {string} privateKey           Private key to sign transaction.
     * @returns {Promise<boolean>}          Value confirming successful transaction broadcasting.
     */
    MiningModule.prototype.setDesiredMinerCount = function (accountId, desiredNumOfMiners, privateKey) {
        var _this = this;
        return new Promise(function (resolve, reject) {
            if (!accountId || desiredNumOfMiners === undefined || !privateKey) {
                reject('missing_parameter');
                return;
            }
            var operation = new database_1.DatabaseOperations.GetAccounts([accountId]);
            _this.dbApi.execute(operation)
                .then(function (accounts) {
                if (!accounts || accounts.length === 0) {
                    reject('account_not_found');
                    return;
                }
                var account = accounts[0];
                if (account.options.votes.length < desiredNumOfMiners) {
                    reject(_this.handleError('unable_to_place_vote', 'Number of desired miners cannot be higher than number of voted miners.'));
                    return;
                }
                var options = account.options;
                options.num_miner = desiredNumOfMiners;
                var operation = new transaction_1.Operations.AccountUpdateOperation(accountId, account.owner, account.active, options, {});
                var transaction = new transactionBuilder_1.TransactionBuilder();
                var added = transaction.addOperation(operation);
                if (added === '') {
                    transaction.broadcast(privateKey)
                        .then(function (res) { return resolve(true); })
                        .catch(function (err) { return reject(_this.handleError(mining_1.MiningError.transaction_broadcast_failed, err)); });
                }
                else {
                    reject(_this.handleError(mining_1.MiningError.syntactic_error, added));
                    return;
                }
            })
                .catch(function (err) { return reject(_this.handleError(mining_1.MiningError.database_fetch_failed, err)); });
        });
    };
    /**
     * Create miner.
     * https://docs.decent.ch/developer/classgraphene_1_1wallet_1_1detail_1_1wallet__api__impl.html#a71fd1099d86cf82f0c4a61f9a2d5803b
     *
     * @param {string} minerAccountId       Id of account which will be miner.
     * @param {string} URL                  URL to miner promotional web page.
     * @param {string} signingPublicKey     Public key used to signing mining operations.
     * @param {string} privateKey           Private key to sign transaction.
     * @returns {Promise<boolean>}          Value confirming successful transaction broadcasting.
     */
    MiningModule.prototype.createMiner = function (minerAccountId, URL, signingPublicKey, privateKey) {
        var _this = this;
        return new Promise((function (resolve, reject) {
            _this.apiConnector.connect()
                .then(function (res) {
                var operation = new transaction_1.Operations.MinerCreate(minerAccountId, URL, signingPublicKey);
                var transaction = new transactionBuilder_1.TransactionBuilder();
                var added = transaction.addOperation(operation);
                if (added === '') {
                    transaction.broadcast(privateKey)
                        .then(function (res) { return resolve(true); })
                        .catch(function (err) { return reject(_this.handleError(mining_1.MiningError.transaction_broadcast_failed, err)); });
                }
                else {
                    reject(_this.handleError(mining_1.MiningError.syntactic_error, added));
                    return;
                }
            })
                .catch(function (err) { return reject(_this.handleError(mining_1.MiningError.connection_failed, err)); });
        }));
    };
    /**
     * Remove your vote from selected miner.
     *
     * @param {string} miner            Miner to un-vote, in format '1.4.X'. Example '1.4.5'.
     * @param {string} account          Account id to un-vote miner from, in format '1.2.X'. Example '1.2.345'.
     * @param {string} privateKeyWif    Private key to sign thr transaction.
     * @returns {Promise<boolean>}      Value confirming successful transaction broadcasting.
     */
    MiningModule.prototype.unvoteMiner = function (miner, account, privateKeyWif) {
        return this.unvoteMiners([miner], account, privateKeyWif);
    };
    /**
     * Remove your votes from multiple miners.
     *
     * @param {string} miners           List of miners to un-vote, in format '1.4.X'. Example ['1.4.5', '1.4.6'].
     * @param {string} account          Account id to un-vote miner from, in format '1.2.X'. Example '1.2.345'.
     * @param {string} privateKeyWif    Private key to sign thr transaction.
     * @returns {Promise<boolean>}      Value confirming successful transaction broadcasting.
     */
    MiningModule.prototype.unvoteMiners = function (miners, account, privateKeyWif) {
        var _this = this;
        return new Promise(function (resolve, reject) {
            _this.chainApi.fetch(new chain_1.ChainMethods.GetAccount(account))
                .then(function (res) {
                var voterAccount = res[0];
                var voter = JSON.parse(JSON.stringify(voterAccount));
                var operation = new database_1.DatabaseOperations.GetMiners(miners);
                _this.dbApi.execute(operation)
                    .then(function (res) {
                    res.forEach(function (miner) {
                        var voteIndex = voter.options.votes.indexOf(miner.vote_id);
                        voter.options.votes.splice(voteIndex, 1);
                    });
                    if (voter.options.votes.length < voter.options.num_miner) {
                        reject(_this.handleError(account_1.AccountError.cannot_update_miner_votes, 'Number of votes cannot be lower as desired miners number'));
                        return;
                    }
                    var op = new transaction_1.Operations.AccountUpdateOperation(account, voter.owner, voter.active, voter.options, {});
                    var transaction = new transactionBuilder_1.TransactionBuilder();
                    var added = transaction.addOperation(op);
                    if (added === '') {
                        transaction.broadcast(privateKeyWif)
                            .then(function (res) { return resolve(true); })
                            .catch(function (err) { return reject(err); });
                    }
                    else {
                        reject(_this.handleError(mining_1.MiningError.syntactic_error, added));
                        return;
                    }
                })
                    .catch(function (err) { return reject(_this.handleError(account_1.AccountError.database_operation_failed, err)); });
            })
                .catch(function (err) { return reject(_this.handleError(account_1.AccountError.account_fetch_failed, err)); });
        });
    };
    /**
     * Vote for selected miner.
     * https://docs.decent.ch/developer/classgraphene_1_1wallet_1_1detail_1_1wallet__api__impl.html#ab0e2ae4331187fd07ad60cd090a4711f
     *
     * @param {string} miner            Miner to vote for, in format '1.4.X'. Example '1.4.5'.
     * @param {string} account          Account id to vote miner for, in format '1.2.X'. Example '1.2.345'.
     * @param {string} privateKeyWif    Private key to sign thr transaction.
     * @returns {Promise<boolean>}      Value confirming successful transaction broadcasting.
     */
    MiningModule.prototype.voteForMiner = function (miner, account, privateKeyWif) {
        return this.voteForMiners([miner], account, privateKeyWif);
    };
    /**
     * Add votes to multiple miners.
     * This method is also called on voteForMiner.
     *
     * @param {string} miners           List of miners to vote for, in format '1.4.X'. Example ['1.4.5', '1.4.6'].
     * @param {string} account          Account id to vote miner for, in format '1.2.X'. Example '1.2.345'.
     * @param {string} privateKeyWif    Private key to sign thr transaction.
     * @returns {Promise<boolean>}      Value confirming successful transaction broadcasting.
     */
    MiningModule.prototype.voteForMiners = function (miners, account, privateKeyWif) {
        var _this = this;
        return new Promise(function (resolve, reject) {
            _this.chainApi.fetch(new chain_1.ChainMethods.GetAccount(account))
                .then(function (res) {
                var voterAccount = res[0];
                var voter = JSON.parse(JSON.stringify(voterAccount));
                var operation = new database_1.DatabaseOperations.GetMiners(miners);
                _this.dbApi.execute(operation)
                    .then(function (res) {
                    (_a = voter.options.votes).push.apply(_a, res.map(function (miner) { return miner.vote_id; }));
                    voter.options.votes.sort(function (e1, e2) {
                        return Number(e1.split(':')[1]) - Number(e2.split(':')[1]);
                    });
                    var op = new transaction_1.Operations.AccountUpdateOperation(account, voter.owner, voter.active, voter.options, {});
                    var transaction = new transactionBuilder_1.TransactionBuilder();
                    var added = transaction.addOperation(op);
                    if (added === '') {
                        transaction.broadcast(privateKeyWif)
                            .then(function (res) { return resolve(true); })
                            .catch(function (err) {
                            console.log(err);
                            var errorMessage = 'transaction_broadcast_failed';
                            if (err.stack.indexOf('duplicate') >= 0) {
                                errorMessage = 'duplicate_parameter_set';
                            }
                            reject(errorMessage);
                        });
                    }
                    else {
                        reject(_this.handleError(mining_1.MiningError.syntactic_error, added));
                        return;
                    }
                    var _a;
                })
                    .catch(function (err) { return reject(_this.handleError(account_1.AccountError.database_operation_failed, err)); });
            })
                .catch(function (err) { return reject(_this.handleError(account_1.AccountError.account_fetch_failed, err)); });
        });
    };
    /**
     * Bulk operation to vote and unvote miners in one operation. Use to avoid paying fee for multiple vote operation.
     *
     * @param {string[]} voteMiners     List of miners to vote for, in format '1.4.X'. Example ['1.4.5', '1.4.6'].
     * @param {string[]} unvoteMiners   List of miners to un-vote, in format '1.4.X'. Example ['1.4.5', '1.4.6'].
     * @param {string} accountId        Id of account vote changes will be made to, in format '1.2.X'. Example '1.2.345'.
     * @param {string} privateKey       Private key to sign the transaction.
     * @returns {Promise<boolean>}      Value confirming successful transaction broadcasting.
     */
    MiningModule.prototype.voteUnvoteMiners = function (voteMiners, unvoteMiners, accountId, privateKey) {
        var _this = this;
        return new Promise(function (resolve, reject) {
            _this.chainApi.fetch(new chain_1.ChainMethods.GetAccount(accountId))
                .then(function (res) {
                if (!res[0]) {
                    reject(_this.handleError(account_1.AccountError.account_does_not_exist, ''));
                    return;
                }
                var voterAcc = res[0];
                var voter = JSON.parse(JSON.stringify(voterAcc));
                var miners = [].concat.apply([], voteMiners.concat(unvoteMiners));
                var operation = new database_1.DatabaseOperations.GetMiners(miners);
                _this.dbApi.execute(operation)
                    .then(function (res) {
                    var minersToVote = MiningModule.createVoteIdList(voteMiners, res);
                    var minersToUnvote = MiningModule.createVoteIdList(unvoteMiners, res);
                    var finalMiners = MiningModule.removeVotedMiners(voter.options.votes, minersToUnvote);
                    finalMiners.push.apply(finalMiners, minersToVote);
                    if (finalMiners.length < voter.options.num_miner) {
                        reject(_this.handleError(account_1.AccountError.cannot_update_miner_votes, 'Number of votes cannot be lower as desired miners number'));
                        return;
                    }
                    var newOptions = Object.assign({}, voter.options);
                    newOptions.votes = MiningModule.getSortedMiners(finalMiners);
                    var accountUpdateOp = new transaction_1.Operations.AccountUpdateOperation(accountId, voter.owner, voter.active, newOptions, {});
                    var transaction = new transactionBuilder_1.TransactionBuilder();
                    var added = transaction.addOperation(accountUpdateOp);
                    if (added === '') {
                        transaction.broadcast(privateKey)
                            .then(function (res) { return resolve(true); })
                            .catch(function (err) { return reject(_this.handleError(account_1.AccountError.transaction_broadcast_failed, err)); });
                    }
                    else {
                        reject(_this.handleError(mining_1.MiningError.syntactic_error, added));
                        return;
                    }
                })
                    .catch(function (err) { return reject(_this.handleError(account_1.AccountError.database_operation_failed, err)); });
            })
                .catch(function (err) { return reject(_this.handleError(account_1.AccountError.account_fetch_failed, err)); });
        });
    };
    /**
     * List balance for user in vesting.
     * https://docs.decent.ch/developer/classgraphene_1_1app_1_1database__api__impl.html#a4e7c681a6c7996225c714f8dc6d061a8
     *
     * @param {string} accountId                    Account id of miner in format '1.2.X'. Example '1.2.345'.
     * @returns {Promise<Block.VestingBalance[]>}   VestingBalance object.
     */
    MiningModule.prototype.getVestingBalances = function (accountId) {
        var _this = this;
        return new Promise(function (resolve, reject) {
            var operation = new database_1.DatabaseOperations.GetVestingBalances(accountId);
            _this.dbApi.execute(operation)
                .then(function (res) { return resolve(res); })
                .catch(function (err) { return reject(_this.handleError(mining_1.MiningError.database_fetch_failed, err)); });
        });
    };
    /**
     * Update info in miner account.
     * https://docs.decent.ch/developer/classgraphene_1_1wallet_1_1detail_1_1wallet__api__impl.html#a4d94757da6cc355932fa01a0302e9007
     *
     * @param {string} minerId                  Miner id in format '1.4.X'. Example '1.4.56'.
     * @param {string} minerAccountId           Account id of miner in format '1.2.X'. Example '1.2.345'.
     * @param {MinerUpdateData} updateData      Information to be changed in miner account.
     * @param {string} privateKey               Miner's private key to sign the transaction.
     * @returns {Promise<boolean>}              Value confirming successful transaction broadcasting.
     */
    MiningModule.prototype.updateMiner = function (minerId, minerAccountId, updateData, privateKey) {
        var _this = this;
        return new Promise(function (resolve, reject) {
            var getMinerOp = new database_1.DatabaseOperations.GetMiners([minerId]);
            _this.dbApi.execute(getMinerOp)
                .then(function (miners) {
                if (!miners || miners.length === 0) {
                    reject(_this.handleError(mining_1.MiningError.miner_does_not_exist, ''));
                    return;
                }
                var miner = miners[0];
                var operation = new transaction_1.Operations.MinerUpdate(minerId, minerAccountId, updateData.newUrl || miner.url, updateData.newSigningKey || miner.signing_key);
                var transaction = new transactionBuilder_1.TransactionBuilder();
                var added = transaction.addOperation(operation);
                if (added === '') {
                    transaction.broadcast(privateKey)
                        .then(function (res) { return resolve(true); })
                        .catch(function (err) { return reject(_this.handleError(mining_1.MiningError.database_fetch_failed, err)); });
                }
                else {
                    reject(_this.handleError(mining_1.MiningError.syntactic_error, added));
                    return;
                }
            })
                .catch(function (err) { return reject(_this.handleError(mining_1.MiningError.miner_does_not_exist, err)); });
        });
    };
    /**
     * Withdraw amount from vesting for account.
     * NOTE: 24h after amount is vested
     * https://docs.decent.ch/developer/classgraphene_1_1wallet_1_1detail_1_1wallet__api__impl.html#abb116624419b0f7142d725150561534a
     *
     * @param {string} vestinBalanceId      Vesting balance id in format '1.9.X'. Example '1.9.345'.
     * @param {string} ownerId              Vesting balance owner account id in format '1.2.X'. Example '1.2.345'.
     * @param {number} amount               Amount of balance to be withdrawn.
     * @param {string} assetId              Asset id of amount to be withdrawn.
     * @param {string} privateKey           Owner's private key to sign the transaction.
     * @returns {Promise<boolean>}          Value confirming successful transaction broadcasting.
     */
    MiningModule.prototype.withdrawVesting = function (vestinBalanceId, ownerId, amount, assetId, privateKey) {
        var _this = this;
        return new Promise(function (resolve, reject) {
            var operation = new transaction_1.Operations.VestingBalanceWithdraw(vestinBalanceId, ownerId, {
                amount: amount,
                asset_id: assetId
            });
            var transaction = new transactionBuilder_1.TransactionBuilder();
            var added = transaction.addOperation(operation);
            if (added === '') {
                transaction.broadcast(privateKey)
                    .then(function (res) { return resolve(true); })
                    .catch(function (err) { return reject(_this.handleError(mining_1.MiningError.transaction_broadcast_failed, err)); });
            }
            else {
                reject(_this.handleError(mining_1.MiningError.syntactic_error, added));
            }
        });
    };
    /**
     * Account what is selected as proxy, his votes is taken as yours.
     * Automatically vote for same miners as voting proxy account voted, with your balance.
     * https://docs.decent.ch/developer/classgraphene_1_1wallet_1_1detail_1_1wallet__api__impl.html#a9c571d810992f8a72142ace75e74eceb
     *
     * @param {string} accountId            Account if in format '1.2.X'. Example '1.2.345'.
     * @param {string} votingAccountId      Id of account to be set as voting proxy, in format '1.2.X'. Example '1.2.345'.
     * @param {string} privateKey           Private used to sign transaction.
     * @returns {Promise<boolean>}          Value confirming successful transaction broadcasting.
     */
    MiningModule.prototype.setVotingProxy = function (accountId, votingAccountId, privateKey) {
        var _this = this;
        if (votingAccountId === void 0) { votingAccountId = ''; }
        return new Promise(function (resolve, reject) {
            _this.chainApi.fetch(new chain_1.ChainMethods.GetAccount(accountId))
                .then(function (result) {
                if (result.length === 0 || !result[0]) {
                    reject(_this.handleError(mining_1.MiningError.account_fetch_failed));
                    return;
                }
                var account = result[0];
                var newOptions = Object.assign({}, account.options);
                if (votingAccountId !== '') {
                    if (newOptions.voting_account === votingAccountId) {
                        reject(_this.handleError(mining_1.MiningError.duplicate_settings, 'Voting account already set'));
                        return;
                    }
                }
                else {
                    if (newOptions.voting_account === MiningModule.CHAIN_PROXY_TO_SELF) {
                        reject(_this.handleError(mining_1.MiningError.duplicate_settings, 'Voting account already set'));
                        return;
                    }
                    newOptions.voting_account = MiningModule.CHAIN_PROXY_TO_SELF;
                }
                var accountUpdateOperation = new transaction_1.Operations.AccountUpdateOperation(accountId, account.owner, account.active, newOptions, {});
                var transaction = new transactionBuilder_1.TransactionBuilder();
                var added = transaction.addOperation(accountUpdateOperation);
                if (added === '') {
                    transaction.broadcast(privateKey)
                        .then(function (res) { return resolve(true); })
                        .catch(function (err) { return reject(_this.handleError(mining_1.MiningError.transaction_broadcast_failed, err)); });
                }
                else {
                    reject(_this.handleError(mining_1.MiningError.syntactic_error, added));
                    return;
                }
            })
                .catch(function (err) { return _this.handleError(mining_1.MiningError.account_fetch_failed, err); });
        });
    };
    /**
     * List miners in DCore network.
     * https://docs.decent.ch/developer/group___wallet_a_p_i___mining.html#gadd09ed33a90485888d6d885ddaa82fcd
     *
     * @param {string} fromId                   Miner id to start list from, in format '1.4.X'. Example '1.4.56',
     *                                          Use '0.0.0' to list from the beginning.
     * @param {number} limit                    Size of result list. Default 100(Max)
     * @returns {Promise<MinerNameIdPair[]>}    List of MinerNameIdPair.
     */
    MiningModule.prototype.listMiners = function (fromId, limit) {
        var _this = this;
        if (limit === void 0) { limit = 100; }
        return new Promise((function (resolve, reject) {
            var operation = new database_1.DatabaseOperations.LookupMiners(fromId, limit);
            _this.dbApi.execute(operation)
                .then(function (miners) {
                resolve(miners);
            })
                .catch(function (err) { return reject(_this.handleError(mining_1.MiningError.database_fetch_failed, err)); });
        }));
    };
    /**
     * Get miner object.
     * https://docs.decent.ch/developer/classgraphene_1_1wallet_1_1detail_1_1wallet__api__impl.html#a43b1380512f11c9f6963ce2a5c9c81c9
     *
     * @param {string} minerId      Miner id to be fetched, in format '1.4.X'. Example '1.4.56'.
     * @returns {Promise<Miner>}    Miner object.
     */
    MiningModule.prototype.getMiner = function (minerId) {
        var _this = this;
        return new Promise(function (resolve, reject) {
            var operation = new database_1.DatabaseOperations.GetMiners([minerId]);
            _this.dbApi.execute(operation)
                .then(function (miners) {
                if (!miners || !miners[0]) {
                    reject(_this.handleError(mining_1.MiningError.miner_does_not_exist));
                    return;
                }
                resolve(miners[0]);
            })
                .catch(function (err) { return reject(_this.handleError(mining_1.MiningError.database_fetch_failed, err)); });
        });
    };
    MiningModule.CHAIN_PROXY_TO_SELF = '';
    return MiningModule;
}(ApiModule_1.ApiModule));
exports.MiningModule = MiningModule;
//# sourceMappingURL=mining.js.map