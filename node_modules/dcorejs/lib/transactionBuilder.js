"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
/**
 * @module TransactionBuilder
 */
var helpers_1 = require("./helpers");
var utils_1 = require("./utils");
/**
 * Class contains available transaction operation names constants
 */
var TransactionBuilder = /** @class */ (function () {
    function TransactionBuilder() {
        this._operations = [];
        this._transaction = new helpers_1.dcorejs_lib.TransactionBuilder();
    }
    Object.defineProperty(TransactionBuilder.prototype, "operations", {
        /**
         * List of operations added to transaction
         * @return {Operation[]}
         */
        get: function () {
            return this._operations;
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(TransactionBuilder.prototype, "transaction", {
        /**
         * Get dcorejs-lib format transaction.
         *
         * @returns {any}   dcorejs-lib transaction object.
         */
        get: function () {
            return this._transaction;
        },
        enumerable: true,
        configurable: true
    });
    /**
     * Append new operation to transaction object.
     *
     * @param {Operation} operation     Operation to append to transaction.
     * @return {boolean}                Successful operation add value.
     */
    TransactionBuilder.prototype.addOperation = function (operation) {
        try {
            this._transaction.add_type_operation(operation.name, operation.operation);
            this._operations.push(operation);
            return '';
        }
        catch (exception) {
            return exception;
        }
    };
    /**
     * Transform transaction into proposal type transaction.
     *
     * @param {ProposalCreateParameters} proposalParameters     Proposal transaction parameters.
     */
    TransactionBuilder.prototype.propose = function (proposalParameters) {
        this._transaction.propose(proposalParameters);
    };
    /**
     * Broadcast transaction to DCore blockchain.
     *
     * @param {string} privateKey       Private key to sign transaction in WIF(hex)(Wallet Import Format) format .
     * @param sign                      If value is 'true' transaction will be singed, in 'false' transaction will not be signed.
     *                                  Default 'true'
     * @return {Promise<void>}          Void.
     */
    TransactionBuilder.prototype.broadcast = function (privateKey, sign) {
        var _this = this;
        if (sign === void 0) { sign = true; }
        var secret = utils_1.Utils.privateKeyFromWif(privateKey);
        return new Promise(function (resolve, reject) {
            _this.setTransactionFees()
                .then(function () {
                if (sign) {
                    _this.signTransaction(secret);
                }
                _this._transaction.broadcast()
                    .then(function () {
                    resolve();
                })
                    .catch(function (err) {
                    reject(err);
                });
            })
                .catch(function (err) {
                reject(err);
            });
        });
    };
    /**
     * Set transaction fee required for transaction operation
     *
     * @return {Promise<void>}  Void.
     */
    TransactionBuilder.prototype.setTransactionFees = function () {
        var _this = this;
        return new Promise(function (resolve, reject) {
            _this._transaction.set_required_fees()
                .then(function () {
                resolve();
            })
                .catch(function () {
                reject();
            });
        });
    };
    /**
     * Sign transaction with given private/public key pair.
     *
     * @param {KeyPrivate} privateKey   Private key to sign transaction.
     * @param {KeyPublic} publicKey     Public key related to private key.
     */
    TransactionBuilder.prototype.signTransaction = function (privateKey) {
        var publicKey = utils_1.KeyPrivate.fromWif(privateKey.stringKey).getPublicKey().key;
        this._transaction.add_signer(privateKey.key, publicKey);
    };
    /**
     * Replace operation on operationIndex with newOperation
     *
     * @param {number} operationIndex               Index of operation to replace. Must be greater than 0 and smaller than
     *                                              length of operations.
     * @param {Operation} newOperation              Operation to be placed to index.
     * @returns {boolean}                           Returns true if replaced, false otherwise.
     */
    TransactionBuilder.prototype.replaceOperation = function (operationIndex, newOperation) {
        if (operationIndex >= 0 && operationIndex < this._operations.length) {
            try {
                this._transaction.add_type_operation(newOperation.name, newOperation.operation);
                this._operations[operationIndex] = newOperation;
                return true;
            }
            catch (exception) {
                console.log(exception);
                return false;
            }
        }
        return false;
    };
    /**
     * Displays current transaction
     * @returns {any}   dcorejs-lib format transaction object.
     */
    TransactionBuilder.prototype.previewTransaction = function () {
        return this._transaction;
    };
    return TransactionBuilder;
}());
exports.TransactionBuilder = TransactionBuilder;
//# sourceMappingURL=transactionBuilder.js.map